## תכונות: הגדרת התנהגות משותפת

_תכונה_ מגדירה פונקציונאליות שטיפוס יכול לשתף עם טיפוסים אחרים. ניתן להשתמש בתכונות על מנת להגדיר התנהגות משותפת בצורה אבסטרקטית. בהקשר זה, משתמשים _במגבילי תכונות_ כדי לציין שטיפוס גנרי חייב לקיים תכונות מסוימות.

> הערה: תכונות בראסט דומות לקונספט שבשפות תכנות אחרות נקרא אינטרפייס (interface), אולם עם כמה הבדלים.

### הגדרת תכונה

ההתנהגות של טיפוס מורכבת מהמתודות שזמינות לקריאה על הטיפוס. טיפוסים שונים משתפים את אותה ההתנהגות אם ניתן לקרוא לאותן המתודות על כל הטיפוסים האלה. הגדרה של תכונה היא דרך לקבץ יחדיו חותמי מתודות ובכך להגדיר אוסף של התנהגויות הדרושות למטרה כלשהיא.

לדוגמא, נאמר שיש לנו כמה מבנים שמכילים כמה סוגים וכמויות של טקסט: מבנה בשם `NewsArticle` עם כתבה עיתונאית, ומבנה בשם `Tweet` שמכיל טקסט של לא יותר מ-280 תוים יחד עם מטה-דאטה שמציין האם זה ציוץ חדש, ציוץ חוזר, או תגובה לציוץ אחר.

אנו מעוניינים ליצור מכולה בשם `aggregator` לניהול אוספי מדיה שתוכל להציג סיכומים של דאטה שיכול להיות מאוכסן במופעי `NewsArticle` או `Tweet`. על מנת לעשות זאת, נצטרך סיכום מכל טיפוס, ונרצה לקבל סיכום זה מהפעלת מתודה בשם `summarize` על מופעים. רשימה 10-12 מציגה את ההגדרה של התכונה הפומבית `Summary` שמבטאת התנהגות זו.

<span class="filename">Filename: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-12/src/lib.rs}}
```

<span class="caption">רשימה 10-12: התכונה `Summary` שמורכבת מההתנהגות שהמתודה `summarize` מספקת</span>

כאן, אנו מכריזים על תכונה תוך שימוש במילת המפתח `trait` ולאחריה שם התכונה, שבמקרה זה הוא `Summary`. בנוסף, הכרזנו שהתכונה היא פומבית, על-ידי שימוש ב-`pub`, כך שמכולות המסתמכות על המכולה שלנו יוכלו להשתמש בתכונה זו, כפי שנראה בכמה דוגמאות. בתוך הסוגרים המסולסלים, אנו מכריזים על חותמי המתודות שמתארות את ההתנהגות של הטיפוסים שממשים את התכונה, ובמקרה זה מדובר על `fn summarize(&self) -> String`.

אחרי חותם המתודה, במקום לספק מימוש בתוך סוגרים מסולסלים, אנו מסיימים בסימן הנקודה-פסיק. כל טיפוס שמממש תכונה זו חייב לספק את ההתנהגות הרצויה שלו על-ידי מימוש גוף המתודה. הקומפילר יוודא שכל טיפוס שמקיים את התכונה `Summary` מממש את המתודה `summarize` עם החותם הזה בדיוק.

תכונה יכולה להכריז על מספר רק של מתודות: חותמי המתודות מופיעות אחת לאחת ברשימה המופרדת על-ידי סימני נקודה-פסיק.

### מימוש תכונה עבור טיפוס

כעת משהגדרנו את החותמים הרצויים של המתודות בתכונה `Summary`, ניתן לממש את התכונה עבור הטיפוסים שלנו במכולה לניהול אוספי מדיה. רשימה 10-13 מציגה מימוש של התכונה `Summary` עבור המבנה `NewsArticle` שמשתמש בכותרת, שם הכותב\ת, והמיקום לל מנת ליצור את הערך המוחזר של `summarize`. עבור המבנה `Tweet`, אנו מגדירים את `summarize` כשם המשתמש ולאחריו הציוץ במלואו, תחת ההנחה שתוכן הציוץ תמיד מוגבל ל-280 תווים.

<span class="filename">Filename: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-13/src/lib.rs:here}}
```

<span class="caption">רשימה 10-13: מימוש של התכונה `Summary` עבור המבנים `NewsArticle` ו-`Tweet`</span>

מימוש של תכונה עבור טיפוס דומה למימוש רגיל של מתודות. ההבדל הוא שאחרי ה-`impl` מציינים את שם התכונה שאנו מממשים, ואז את מילת המפתח `for`, ולאחריה את שם הטיפוס שעבורו אנו מממשים את התכונה. בתוך בלוק ה-`impl` אנו ממקמים את חותמי המתודות עליהם התכונה מכריזה. במקום לסיים כל חותם כזה בנקודה-פסיק, אנו משתמשים בסוגרים מסולסלים וכותבים את גוף המתודה עם קוד שמממש את הלוגיקה של ההתנהגות הרצויה של התכונה עבור הטיפוס הספציפי עבורו אנו מממשים את התכונה.

כעת, משהספריה מימשה את התכונה `Summary` עבור `NewsArticle` ו-`Tweet`, משתמשי המכולה יכולים לקרוא למתודות על מופעים של `NewsArticle` ושל `Tweet` באותה הדרך בה קוראים למתודות רגילות. ההבדל היחיד הוא שיש להכניס גם את התכונה, ולא רק את הטיפוסים, למתחם. הינה דוגמא כיצד מכולה בינארית יכולה להשתמש במכולת הספריה `aggregator`:

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-01-calling-trait-method/src/main.rs}}
```

קוד זה מדפיס `1 new tweet: horse_ebooks: of course, as you probably already
know, people`.

מכולות אחרות שמסתמכות על המכולה `aggregator` יכולות להכניס את התכונה `Summary` למתחם ולממש את `Summary` על טיפוסים משלהם. מגבלה חשובה היא שניתן לממש תכונה על טיפוס בתנאי שאו שהתכונה או שהטיפוס מוגדרים לוקאלית במכולה בה מתבצע המימוש. למשל, ניתן לממש תכונות של הספריה הסטנדרטית, כמו `Display`, על טיפוסים כמו `Tweet` כחלק מהמכולה `aggregator`, כיוון שהטיפוס `Tweet` מוגדר לוקאלית במכולה `aggregator`. ניתן גם לממש את התכונה `Summary` עבור `Vec<T>` במכולה `aggregator`, כיוון שהתכונה `Summary` מוגדרת לוקאלית במכולה `aggregator`.

אבל אי-אפשר לממש תכונות חיצוניות עבור טיפוסים חיצוניים. למשל, לא ניתן לממש את התכונה `Display` עבור `Vec<T>` בתוך המכולה `aggregator`, משום שגם התכונה `Display` וגם הטיפוס `Vec<T>` מוגדרים בספריה הסטנדרטית, ולכן אינם לוקאלים למכולה `aggregator`. מגבלה זו מהווה חלק מתכונה של ראסט שנקראת _קוהרנטיות_ (coherence), וביתר פירוט _כלל היתמות_ (the orphan rule), שנקרא כך מכיוון שטיפוס האב אינו נמצא. כלל זה מבטיח שקוד של אחרים לא יוכל לשבור את הקוד שלכם, ולהפך. ללא כלל זה, שתי מכולות היו יכולות לממש את אותה התכונה עבור אותו הטיפוס, וראסט לא תוכל לדעת באיזה מימוש להשתמש.

### מימושי ברירת-מחדל

לעיתים מועיל שיש התנהגות ברירת-מחדל עבור כמה, או כל, המתודות בתכונה במקום להצטרך לממש את כל המתודות עבור כל טיפוס וטיפוס.
במצב זה, בעודנו מממשים את התכונה עבור טיפוס מסוים, ניתן לשמור על המימוש הקיים או להחליפו במימוש אחר שמיישם התנהגות שונה מברירת המחדל.

ברשימה 10-14 אנו מספקים מחרוזת כברירת מחדל עבור המתודה `summarize` שבתכונה `Summary` במקום רק להכריז על חותם המתודה, כפי שעשינו ברשימה 10-12.

<span class="filename">Filename: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-14/src/lib.rs:here}}
```

<span class="caption">רשימה 10-14: הגדרת התכונה `Summary` עם מימוש ברירת-מחדל עבור המתודה `summarize`</span>

בכדי להשתמש במימוש ברירת המחדל כדי לסכם מופעים של `NewsArticle`, כל שיש לעשות הוא לספק בלוק `impl` ריק: `impl Summary for NewsArticle {}`.

אומנם לא הגדרנו ישירות את המתודה `summarize` עבור `NewsArticle`, אולם בתכונה קיים מימוש ברירת מחדל וציינו כי `NewsArticle` מקיים את התכונה `Summary`. כתוצאה מכך, עדיין ניתן לקרוא למתודה `summarize` על מופעים של `NewsArticle`, כך:

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-02-calling-default-impl/src/main.rs:here}}
```

קוד זה מדפיס `New article available! (Read more...)`.

יצירת מימוש ברירת המחדל אינה דורשת מאיתנו לשנות דבר בקשר למימוש של `Summary` עבור `Tweet` ברשימה 10-13. הסיבה היא שהתחביר שמחליף מימוש ברירת מחדל קיימת הוא זהה לתחביר של מימוש מתודה של תכונה שאין לה מימוש ברירת מחדל.

מימושי ברירת מחדל יכולים לקרוא למתודות אחרות בתכונה, אפילו אם למתודות אלה אין מימושי ברירת מחדל. בצורה זו, תכונה יכולה לספק פונקציונאליות שימושית רבה ולדרוש ממממשים לספק רק חלק קטן של המימושים הדרושים לתכונה. למשל, ניתן להכריז כי בתכונה `Summary` יש את המתודה `summarize_author`, שמימושה נדרש, ואז להגדיר את המתודה `summarize` עם מימוש ברירת מחדל שקורא למתודה `summarize_author`:

```rust,noplayground
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-03-default-impl-calls-other-methods/src/lib.rs:here}}
```

כדי להשתמש בגרסה זו של `Summary`, כל שיש לעשות הוא לתת מימוש עבור המתודה `summarize_author` בזמן שמממשים את התכונה עבור טיפוס:

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-03-default-impl-calls-other-methods/src/lib.rs:impl}}
```

מרגע שנגדיר את `summarize_author`, נוכל לקרוא ל-`summarize` על מופעים של המבנה `Tweet`, ומימוש ברירת המחדל של `summarize` ישתמש במימוש שסיפקנו עבור המתודה `summarize_author`. בגלל שמימשנו את `summarize_author`, התכונה `Summary` מספקת לנו את ההתנהגות של המתודה `summarize` ללא צורך בכתיבת קוד נוסף.

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-03-default-impl-calls-other-methods/src/main.rs:here}}
```

קוד זה מדפיס `1 new tweet: (Read more from @horse_ebooks...)`.

שימו לב שלא ניתן ניתן לקרוא למימוש ברירת מחדל מתוך יישום שמחליף את ברירת המחדל של אותה המתודה.

### תכונות כפרמטרים

כעת שאתם יודעים כיצד להגדיר ולממש תכונות, נוכל להבין כיצד להשתמש בתכונות על מנת להגדיר פונקציות שמקבלות טיפוסים רבים. אנו עומדים להשתמש בתכונה `Summary` שיישמנו ברשימה 10-13 עבור הטיפוסים `NewsArticle` ו-`Tweet` כדי להגדיר את הפונקציה `notify` שקוראת למתודה `summarize` על הפרמטר `item` שלה, שהוא יכול מהיות מכל טיפוס שהוא שמממש את התכונה `Summary`. לשם כך, אנו משתמשים בתחביר ה-`impl Trait`, כך:

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-04-traits-as-parameters/src/lib.rs:here}}
```

במקום טיפוס קונקרטי עבור הפרמטר `item`, השתמשנו במילת המפתח `impl` ובשם של התכונה. פרמטר זה מקבל כל טיפוס שמממש את התכונה המצויינת. בגוף של הפונקציה `notify`, ניתן לקרוא על `item` לכל תכונה שמגיעה מהתכונה `Summary`, כגון המתודה `summarize`. ניתן לקרוא ל-`notify` ולהעביר לה כל מופע של `NewsArticle` או של `Tweet`. קוד שינסה לקרוא לפונקציה על כל טיפוס אחד, כמו `String` או `i32`, לא יעבור קומפילציה שכן טיפוסים אלה לא מממשים את התכונה `Summary`.

<!-- Old headings. Do not remove or links may break. -->

<a id="fixing-the-largest-function-with-trait-bounds"></a>

#### תחביר מגבילי תכונות

תחביר ה-`impl Trait` עובד במקרים פשוטים אבל הוא בעצם סוכר תחבירי לתצורה ארוכה יותר הידועה _כמגביל תכונה_, שנראית כך:

```rust,ignore
pub fn notify<T: Summary>(item: &T) {
    println!("Breaking news! {}", item.summarize());
}
```

תצורה ארוכה זו שקולה לדוגמא מהסעיף הקודם, אולם היא יותר מפורטת. יש למקם מגבלות תכונה כחלק מההכרזה על פרמטר טיפוס גנרי לאחר הנקודותים ובתוך הסוגרים המשולשים.

תחביר ה-`impl Trait` הוא נוח ומאפשר קוד יותר מתומצת במקרים פשוטים, בעוד שתחביר מגבילי התכונה המלא יכול לבטא מצבים מורכבים יותר. לדוגמא, יכולים להיות שני פרמטרים שמממשים את `Summary`. תוך שימוש בתחביר `impl Trait` זה יראה כך:

```rust,ignore
pub fn notify(item1: &impl Summary, item2: &impl Summary) {
```

שימוש ב-`impl Trait` מומלץ אם אנחנו רוצים שהפונקציה תאפשר ל-`item1` ול-`item2` להיות מטיפוסים שונים (כל עוד שניתהם מממשים את `Summary`). אם נרצה לאכוף על שני הפרמטרים להיות מאותו טיפוס, לאומת זאת, יהיה עלינו להשתמש במגביל תכונה, בצורה הזאת:

```rust,ignore
pub fn notify<T: Summary>(item1: &T, item2: &T) {
```

הטיפוס הגנרי `T` מתפקד כטיפוס של הפרמטרים `item1` ו-`item2` והוא מגביל את הפונקציה ומוודא שהטיפוסים הקונקרטים של הערכים המועברים כארגומנטים ל-`item1` ול-`item2` זהים זה לזה.

#### ציון ריבוי מגבילי תכונה באמצעות התחביר `+`

ניתן גם לציין יותר מתכונה אחת במגביל תכונה. נניח שאנו רוצים ש-`notify` תשתמש בהצגה מפורמטת בנוסף ל-`summarize` עבור `item`: נציין בהגדרת `notify` ש-`item` חייב לממש גם את `Display` וגם את `Summary`. עושים זאת באמצעות התחביר `+`:

```rust,ignore
pub fn notify(item: &(impl Summary + Display)) {
```

התחביר `+` תקף גם עם מגבילי תכונה על טיפוסים גנרים:

```rust,ignore
pub fn notify<T: Summary + Display>(item: &T) {
```

מששני מגבילי התכונה מצויינים, בגוף של `notify` ניתן לקרוא ל-`summarize` וכן להשתמש ב-`{}` כדי לפרמט את `item`.

#### מגבילי תכונה ברורים יותר באמצעות סעיפי `where`

לשימוש בהרבה מגבילי תכונה יש חסרונות. לכל טיפוס גנרי יש את מגבילי התכונה שלו, כך שפונקציות עם כמה פרמטרי טיפוס גנרים יכולות לכלול כמות נכבדת של מגבילי תכונה בין שם הפונקציה ורשימת הפרמטרים שלה, וזה יכול להקשות על קריאת חותם הפונקציה. בשל כך, ראסט מאפשרת תחביר חלופי לציון מגבילי תכונה בתוך סעיף `where` המופיע אחרי חותם הפונקציה. כך שבמקום לכתוב כך:

```rust,ignore
fn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {
```

ניתן להשתמש בסעיף `where`, בצורה הזאת:

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-07-where-clause/src/lib.rs:here}}
```

כך חותם הפונקציה פחות עמוס: שם הפונקציה, רשימת הפרמטרים, וטיפוס הערך המוחזר נמצאים יחדיו, בדומה למצב עבור פונקציה ללא כל מגבילי תכונה.

### החזרת טיפוסים שמממשים תכונות

ניתן גם להשתמש בתחביר `impl Trait` בערך המוחזר כדי להחזיר ערך של טיפוס כלשהו שמממש תכונה, כמוצג כאן:

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-05-returning-impl-trait/src/lib.rs:here}}
```

תוך שימוש ב-`impl Summary` כטיפוס הערך המוחזר, אנו מציינים שהפונקציה `returns_summarizable` מחזירה איזשהו טיפוס שמממש את התכונה `Summary`, מבלי שאנו מספקים טיפוס מוחזר קונקרטי. במקרה זה, `returns_summarizable` מחזיר טיפוס `Tweet`, אבל הקוד הקורא לפונקציה זו לא צריך לדעת זאת.

היכולת לציין טיפוס לערך המוחזר רק לפי התכונה שהוא מיישם היא יעילה במיוחד בהקשר של סגורים ואיטרטורים, עליהם נדון בפרק 13. סגורים ואיטרטורים יוצרים טיפוסים שרק הקומפילר יודע מה הטיפוס שלהם או שהם ארוכים מידי מלציין מפורשות. תחביר ה-`impl Trait` מאפשר לציין בקצרה שפונקציה מחזירה ערך שמממש את התכונה `Iterator` ללא צורך לכתוב טיפוס ארוך ומייגע.

אבל, ניתן להשתמש ב-`impl Trait` רק אם מחזירים ערך יחיד. למשל, קוד זה, שמחזיר או `NewsArticle` או `Tweet`, לא יעבוד אם נציין את הטיפוס המוחזר כ-`impl Summary`:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-06-impl-trait-returns-one-type/src/lib.rs:here}}
```

החזרה של טיפוס `NewsArticle` או `Tweet` לא מותרת בשל מגבלות הקשורות לדרך בה תחביר ה-`impl Trait` מיושם בקומפילר. אנו נראה כיצד ליצור פונקציה עם התנהגות זו בפרק 17.

### שימוש במגבילי תכונה לשם מימוש מותנה של מתודות

על-ידי שימוש במגבילי תכונה עם בלוק `impl` שמשתמש בפרמטרי טיפוס גנרים, ניתן לממש מתודות באופן מותנה עבור טיפוסים שמממשים את התכונה הספציפית. למשל, הטיפוס `Pair<T>` מרשימה 10-15 תמיד מממש את הפונקציה `new` כך שתחזיר מופע חדש של `Pair<T>` (זכרו מהגדרה [“Defining Methods”][methods]<!-- ignore --> מפרק 5 ש-`Self` הוא טיפוס נרדף לטיפוס של בלוק ה-`impl`, שבמקרה זה הוא `Pair<T>`). אבל בבלוק ה-`impl` הבא, `Pair<T>` מממש את המתודה `cmp_display` רק אם הטיפוס הפנימי `T` מממש את התכונה `PartialOrd` שמאפשרת השוואה _וגם_ את התכונה `Display` שמאפשרת הדפסה.

<span class="filename">Filename: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-15/src/lib.rs}}
```

<span class="caption">רשימה 10-15: מימוש מותנה של מתודות עבור טיפוס גנרי בהתאם למגבילי תכונה</span>

ניתן גם לממש תכונה לכל טיפוס בתנאי שהוא מממש תכונה אחרת. מימושים של תכונה על כל טיפוס שמקיים את מגבילי התכונה נקראים _מימושי שמיכה_ (blanket implementations) והם בשימוש נרחב בספריה הסטנדרטית של ראסט. למשל, הספריה הסטנדרטית מממשת את התכונה `ToString` עבור כל טיפוס שמממש את התכונה `Display`. בלוק ה-`impl` בספריה הסטנדרטית נראה כמו הקוד הבא:

```rust,ignore
impl<T: Display> ToString for T {
    // --snip--
}
```

משום שבספריה הסטנדרטית יש מימוש שמיכה זה, ניתן לקרוא למתודה `to_string` אשר מוגדרת בתכונה `ToString` עבור על טיפוס שמממש את התכונה `Display`. לדוגמא, ניתן להפוך מספרים שלמים ליצוג שלהם כערכי מחרוזות בצורה הבאה, משום שמספרים שלמים מממשים את `Display`:

```rust
let s = 3.to_string();
```

מימושי שמיכה מופיעים בתיעוד התכונה תחת הסעיף “Implementors”.

תכונות ומגבילי תכונה מאפשרים לנו לכתוב קוד שמשתמש בפרמטרי טיפוס גנרים על מנת להימנע משכפול קוד אבל גם כדי לציין לקומפילר שאנו מעוניינים שלטיפוס הגנרי תהיה התנהגות מסוימת. הקומפילר יכול אז להשתמש במגביל התכונה כדי לבדוק שכל הטיפוסים הקונקרטים שבשימוש הקוד שלנו מספקים את ההתנהגות הנכונה. בשפות עם טיפוסים דינאמים, נקבל שגיאה בזמן הריצה במידה ונקרא למתודה על טיפוס שלא מממש את המתודה. אבל ראסט מזהה שגיאות אלה בזמן הקומפילציה וכך אנו מטפלים בבעיות לפני שהקוד אפילו רץ. בנוסף, אין הכרח לכתוב קוד שבודק בזמן הריצה האם התנהגות נחוצה קיימת, כיוון שזה כבר מובטח במידה והקוד עבר קומפילציה.
בצורה זו, יעילות הקוד משתפרת וזאת ללא צורך לוותר על הגמישות של ג'נריקס.

[using-trait-objects-that-allow-for-values-of-different-types]: ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types
[methods]: ch05-03-method-syntax.html#defining-methods
