# טיפוסים גנריים, תכונות, ומשך-חיים

בכל שפת תכנות יש כלים לטיפול אפקטיבי בכפילות של מושגים. בראסט, אחד מהכלים האלה הוא _ג'נריקס_: מחזיקי-מקום אבסטרקטים עבור טיפוסים קונקרטים או תכונות אחרות. אנו יכולים לבטא את ההתנהגות של ג'נריקס, או לתאר כיצד הם עומדים ביחס לג'נריקס אחרים, ללא ידיעה מוקדמת אודות מה יתפוס את מקומם בזמן קימפול והרצת הקוד.

פונקציות יכולות לקבל פרמטרים מטיפוס גנרי, במקום טיפוס קונקרטי כמו `i32` או `String`, באותו אופן בו פונקציה מקבלת פרמטרים עם ערכים שאינם ידועים מראש על מנת להריץ את אותו הקוד עם ערכים קונקרטים שונים. למעשה, כבר עשינו שימוש בג'נריקס בפרק 6 עם `Option<T>`, בפרק 8 עם `Vec<T>` ועם `HashMap<K, V>`, ובפרק 9 עם `Result<T, E>`. בפרק זה תראו כיצד להגדיר טיפוסים, פונקציות, ומתודות משלכם עם ג'נריקס!

ראשית, נראה כיצד לבודד קוד ולמקם אותו בפונקציה על מנת להימנע מכפילות קוד. לאחר מכן נעשה שימוש באותה הטכניקה כדי ליצור פונקציה גנרית משתי פונקציות שהשוני היחיד ביניהן הוא רק בטיפוסים של המשתנים שלהם. נסביר גם כיצד להשתמש בטיפוסים גנרים בהגדרות של מבנים ומבחרים.

הנושא הבא יהיה שימוש _בתכונות_ על מנת להגדיר התנהגויות בצורה גנרית. ניתן לשלב תכונות עם טיפוסים גנרים בכדי להטיל מגבלות על טיפוס גנרי כך שיקבל רק טיפוסים בעלי התנהגות מסוימת, בניגוד לסתם כל טיפוס שהוא.

לבסוף, נדון במושג _משך חיים_: סוג של ג'נריקס שמספק לקומפילר מידע אודות יחסים בין הפניות. משכי-חיים מאפשרים לנו לתת לקומפילר מספיק מידע בנוגע לערכים שאולים כך שהוא יוכל לוודא את תקינותן של הפניות במקרים רבים יותר משיוכל לעשות ללא עזרה זו.

## הסרת כפילויות על-ידי מיקום קוד בפונקציה

ג'נריקס מאפשרים לנו להחליף טיפוסים ספציפים במחזיקי-מקום שמייצגים ריבוי טיפוסים, וזאת על מנת להימנע מכפילות קוד. לפני שנצלול לתחביר של ג'נריקס, הבה נתבונן תחילה כיצד להימנע מכפילות בצורה שאינה משתמשת בטיפוסים גנרים, על-ידי מיקום קוד בפונקציה שמחליפה ערכים ספציפים במחזיק-מקום שמייצג ריבוי ערכים. ואז נתשמש באותה הטכניקה על מנת ליצור פונקציה גנרית! תוך התבוננות כיצד לזהות כפילות קוד שניתנת לפתרון באמצעות פונקציה, תתחילו לזהות כפילות קוד שניתנת לפתרון באמצעות ג'נריקס.

אנו פוצחים בתכנית הקצרה ברשימה 10-1 המוצאת את המספר הגדול ביותר ברשימה.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-01/src/main.rs:here}}
```

<span class="caption">רשימה 10-1: מציאת המספר הגדול ביותר ברשימת מספרים</span>

אנו מאכסנים רשימת מספרים במשתנה `number_list` וממקמים הפניה במשתנה `largest` למספר הראשון ברשימה. לאחר מכן אנו עוברים באיטרציה על כל המספרים ברשימה, ובמידה והערך הנוכחי גדול מהמספר שמאוכסן ב-`largest`, אנו מחליפים את ההפניה שבמשתנה זה.
אולם, אם הערך הנוכחי קטן, או שווא, למספר הגדול ביותר שמצאנו עד כה, הערך במשתנה לא משתנה, והקוד עובר הלאה למספר הבא ברשימה. לאחר מעבר על כל המספרים ברשימה, המשתנה `largest` יפנה אל המספר הגדול ביותר, שבמקרה זה הוא 100.

כעת הוטל עלינו למצוא את המספר הגדול ביותר בכל אחת משתי רשימות שונות. על מנת לבצע זאת, נוכל לבחור לשכפל את הקוד מרשימה 10-1 ולהשתמש בדיוק באותה לוגיקה בשני מקומות שונים בתכנית, כפי שמוצג ברשימה 10-2.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-02/src/main.rs}}
```

<span class="caption">רשימה 10-2: קוד למציאת המספר הגדול ביותר _בשתי_ רשימות של מספרים</span>

למרות שקוד זה מבצע את הדרוש, שכפול קוד הוא דבר מיגעה ומועד לטעויות. בנוסף, יהיה עלינו לזכור לעדכן את הקוד במספר מקומות שונים כאשר נרצה לעדכן את ההתנהגות הרצויה.

בכדי להימנע מכפילות זו, ניצור אבסטרקציה על-ידי הגדרת פונקציה שפועלת על כל רשימה שהיא של מספרים שלמים המועברת אליה כפרמטר. פתרון זה הופך את הקוד שלנו לברור יותר ומאפשר לנו לבטא את הלוגיקה של מציאת המספר הגדול ביותר ברשימת מספרים בצורה אבסטרקטית.

ברשימה 10-3, אנו מייצאים את הקוד שמוצא את המספר הגדול ביותר וממקמים אותו בפונקציה ששמה `largest`. ואז אנו קוראים לפונקציה בכדי למצוא את המספר הגדול ביותר בכל אחת משתי הרשימות מרשימה 10-2. נוכל גם להשתמש באותה פונקציה על כל רשימה אחרת של ערכי `i32` בכל מצב עתידי.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-03/src/main.rs:here}}
```

<span class="caption">רשימה 10-3: אבסטרקטיזציה של קוד על מנת למצוא את המספר הגדול ביותר בכל אחת משתי רשימות</span>

הפונקציה `largest` מקבלת פרמטר בשם `list`, שמייצג כל חיתוך של ערכי `i32` שאי פעם נוכל להעביר לפונקציה. כפועל יוצא, כאשר אנו קוראים לפונקציה, הקוד רץ על הערכים הספציפים אותם אנו מעבירים.

לסיכום, הינה הצעדים בהם נקטנו שהובילו מהקוד המופיע ברשימה 10-2 לזה המופיע ברשימה 10-3:

1. זיהוי קוד משוכפל.
2. מיצוי הקוד הכפול לגוף של פונקציה ומיתוג הקלט והערך המוחזר של קוד זה בחותם הפונקציה.
3. עדכון שני המופעים של כפילות הקוד כך שקוראים לפונקציה במקום.

כעת, נעשה שימוש בצעדים אלא ממש עם ג'נריקס על מנת להימנע מכפילות קוד. באותו האופן בו גוף הפונקציה יכול לפעול על _רשימה_ אבסטרקטית במקום על ערכים ספציפים, ג'נריקס מאפשרים לקוד לפעול על טיפוסים אבסטרקטים.

לדוגמא, נניח שהיו לנו שתי פונקציות: אחת המוצאת את האיבר הגדול ביותר בחיתוך של ערכי `i32` ואחת שמוצאת את האיבר הגדול ביותר בחיתוך של ערכי `char`. כיצד נוכל להימנע מכפילות זו? הבה נגלה!
