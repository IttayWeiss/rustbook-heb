## טיפוסי נתונים גנרים

אנו משתמשים בג'נרקיס כדי ליצור הגדרות עבור עצמים כמו חותמי פונקציות או מבנים, שאז ניתנים לשימוש עם טיפוסי נתונים קונקרטים רבים. הבה נתבונן תחילה כיצד להגדיר פונקציות, מבנים, מבחרים, ומתודות תוך שימוש בג'נריקס. לאחר מכן נלמד כיצד ג'נריקס משפיעים על יעילות הקוד.

### בהגדרת פונקציות

כאשר מגדירים פונקציה שמשתמשת בג'נריקס, ממקמים את הג'נריקס בחותם הפונקציה, במקום בו בדרך-כלל מציינים את הטיפוסים של הפרמטרים והערך המוחזר. כך הופך הקוד שלנו לגמיש יותר והוא מספק פונקציונאליות רבה יותר למשתמשי הפונקציה שלנו, וזאת תוך מניעת כפילות קוד.

בעודנו ממשיכים עם הפונקציה `largest`, רשימה 10-4 מציגה שתי פונקציות שכל אחת מהן מוצאת את הערך הגדול ביותר בחיתוך. אנו עומדים לאחד שתי פונקציות אלה לפונקציה יחידה, תוך שימוש בג'נריקס.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-04/src/main.rs:here}}
```

<span class="caption">רשימה 10-4: שתי פונקציות השונות זו מזו רק בשמות ובטיפוסים המופיעים בחותמים שלהן</span>

הפונקציה `largest_i32` היא הפונקציה שיצרנו ברשימה 10-3 והיא מוצאת את ערך ה-`i32` הגדול ביותר בחיתוך. הפונקציה `largest_char` מוצאת את ערך ה-`char` הכי גדול בחיתוך. גופי הפונקציות מכילים בדיוק את אותו הקוד, ואנו עומדים להיפתר מכפילות זו על-ידי הוספת פרמטר בעל טיפוס גנרי בפונקציה אחת ויחידה.

על מנת לציין פרמטרים באצמעות טיפוס גנרי, עלינו לתת שם לטיפוס הגנרי, בדיוק כפי שעושים עבור פרמטרים שמציינים ערכים עבור פונקציה. ניתן להשתמש בכל שם מזהה (identifier) כדי להכריז על פרמטר טיפוס. אנו נרבה להשתמש ב-`T`, כיוון שנהוג בראסט לתת לפרמטרי טיפוס שמות מציינים קצרים, לרוב רק אות אחת, ובראסט המוסכמה לשמות כאלה היא CamelCase. כקיצור למילה “type”, ברירת המחדל היא `T` עבור רוב המתכנתים בראסט.

כאשר משתמשים בפרמטר בגוף של פונקציה, יש להכריז את שם הפרמטר בחותם בכדי שהקומפילר ידע מה משמעות השם.
באופן דומה, כאשר משתמשים בפרמטר טיפוס בחותם של פונקציה, יש להכריז את השם של פרמטר הטיפוס לפני השימוש בו. כדי להגדיר את הפונקציה הגנרית `largest`, יש למקם הכרזת שם טיפוס בתוך סוגרים משולשים `<>`, בין שם הפונקציה ורשימת הפרמטרים, כך:

```rust,ignore
fn largest<T>(list: &[T]) -> &T {
```

אנו קוראים הגדרה זו כך: הפונקציה `largest` היא גנרית מעל הטיפוס `T`. לפונקציה זו יש פרמטר אחד בשם `list`, שהוא חיתוך של ערכים מטיפוס `T`. הפונקציה `largest` מחזירה הפניה לערך מאותו הטיפוס `T`.

רשימה 10-5 מראה את הגדרת הפונקציה `largest` המשתמשת בטיפוס גנרי בחותם שלה. הרשימה מראה גם כיצד ניתן לקרוא לפונקציה עם חיתוך של ערכי `i32` וגם עם חיתוך של ערכי `char`. שימו לב שקוד זה עוד לא יעבור קומפילציה, אבל נטפל בבעיה זו מאוחר יותר בפרק זה.

<span class="filename">Filename: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-05/src/main.rs}}
```

<span class="caption">רשימה 10-5: הפונקציה `largest` תוך שימוש בפרמטרי טיפוס גנרים; קוד זה עוד לא עובר קומפילציה</span>

אם נקמפל את הקוד בשלב זה, נקבל את הודעת השגיאה הבאה:

```console
{{#include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-05/output.txt}}
```

טקסט ההסבר מדבר על `std::cmp::PartialOrd`, וזה מה שנקרא _תכונה_, ונושא התכונות נידון בסעיף הבא. לעת עתה, דעו ששגיאה זו מתריעה על כך שגוף הפנוקציה `largest` לא יוכל לרוץ עם כל הטיפוסים ש-`T` יכול לקבל. כיוון שאנו מועניינים, בגוף הפונקציה, להשוות ערכים מטיפוס `T`, ניתן להשתמש אך ורך בטיפוסים שניתנים להשוואה. על מנת לאפשר השוואות, הספריה הסטנדרטית כוללת את התכונה `std::cmp::PartialOrd` שניתן לממש עבור טיפוסים (ראה נספח C להרחבה על תכונה זו). מעקב אחר הצעת הפתרון בטקסט השגיאה משמשעו הגבלת הטיפוסים ש-`T` יכול לייצג רק לטיפוסים שמממשים את `PartialOrd`, ואז דוגמא זו תעבור קומפילציה שכן הספריה הסטנדרטית מממשת את `PartialOrd`גם עבור `i32` וגם עבור `char`.

### בהגדרת מבנים

ניתן גם להגדיר מבנים תוך שימוש בפרמטרי טיפוס גנרים באחד, או יותר, מהשדות באמצעות התחביר `<>`. רשימה 10-6 מגדירה את המבנה `Point<T>` שמכיל את קורדינטות ה-`x` וה- `y` של איזשהו טיפוס.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-06/src/main.rs}}
```

<span class="caption">רשימה 10-6: המבנה `Point<T>` שמכיל ערכי `x` ו-`y` מטיפוס T </span>

התחביר לשימוש בג'נריקס בהגדרות מבנים דומה לזה שבשימוש בהגדרות פונקציות. ראשית, אנו מכריזים את שם פרמטר הטיפוס בתוך סוגרים משולשים מיד לאחר שם המבנה. לאחר מכן משתמשים בטיפוס הגנרי בהגדרת המבנה במקומות בהם אחרת היינו מציינים מבני נתונים קונקרטים.

שימו לב שכיוון שהכרזנו רק על טיפוס גנרי בודד כחלק מהגדרת `Point<T>`, הגדרה זו אומרת שהמבנה `Point<T>` הוא גנרי מעל הטיפוס `T`, ושהשדות `x` ו-`y` הם _שניהם_ מטיפוס זה, בלי תלות באיזה טיפוס זה יהיה. אם ניצור מופע של `Point<T>` בו נציין ערכים מטיפוסים שונים, כמוצג ברשימה 10-7, הקוד לא יעבור קומפילציה.

<span class="filename">Filename: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-07/src/main.rs}}
```

<span class="caption">רשימה 10-7: השדות `x` ו-`y` חייבים להיות מאותו טיפוס בגלל שלשניהם יש את אותו הטיפוס הגנרי `T` </span>

בדוגמא זו, כאשר מבצעים את ההשמה של הערך 5 ל-`x`, אנו מיידעים את הקומפילר שהטיפוס הגנרי `T` יהיה הטיפוס ak מספרים שלמים עבור המופע של `Point<T>` שאנו יוצרים. אבל אז, כאשר אנו מבצעים את ההשמה של הערך 4.0 עבור `y`, אותו הגדרנו כבעל אותו הטיפוס כמו `x`, נקבל שגיאת אי-התאמה בין טיפוסים כמו זאת:

```console
{{#include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-07/output.txt}}
```

בכדי להגדיר מבנה דמוי `Point` בו `x` ו-`y` שניהם גנרים ויכולים להיות מטיפוסים שונים, נוכל להשתמש בכמה פרמטרי טיפוס גנרים. למשל, ברשימה 10-8, אנו משנים את ההגדרה של `Point` להיות גנרית מעל הטיפוסים `T` ו-`U` כאשר `x` הוא מטיפוס `T` ואילו `y` הוא מטיפוס `U`.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-08/src/main.rs}}
```

<span class="caption">רשימה 10-8: המבנה `Point<T, U>` גנרי מעל שני טיפוסים כך שהשדות `x` ו-`y` יכולים להיות מטיפוסים שונים</span>

כעת כל המופעים האפשרים של `Point` קבילים! בכל הגדרה ניתן להשתמש בכמה פרמטרי טיפוס גנרים שרק תרצו, אבל שימוש בטיפוסים רבים מקשה על קריאת הקוד. במידה ואתם מוצאים שאתם משתמשים בטיפוסים גנרים רבים בקוד שלכם, יתכן שמצב זה מצביע על צורך לפקטר את הקוד לפיסות קטנות יותר.

### בהגדרת מבחרים

כפי שעשינו עם מבנים, ניתן להגדיר מבחרים עם וריאנטים שכוללים טיפוסי נתונים גנרים. הבה נתבונן שוב במבחר `Option<T>` שהספריה הסטנדרטית מספקת, ושעשינו בו שימוש בפרק 6:

```rust
enum Option<T> {
    Some(T),
    None,
}
```

בשלב זה סביר להניח שהגדרה זו נהירה לכם יותר. כפי שאתם רואים, המבחר `Option<T>` הוא גנרי מעל הטיפוס `T` ויש לו שני וריאנטים: `Some`, אשר מאכסן ערך יחיד מטיפוס `T`, והוריאנט `None` שלא מאכסן שום ערך.
על ידי שימוש במבחר `Option<T>`, ניתן לבטא את הרעיון האבסטרקטי של ערך אופציונאלי, וכיוון ש-`Option<T>` הוא גנרי, אנחנו יכולים להשתמש באבסטרקציה זו ללא תלות בטיפוס עצמו של הערך האופציונאלי.

מבחרים יכולים גם להשתמש בכמה טיפוסים גנרים. ההגדרה של המבחר `Result`, אותו פגשנו בפרק 9, הינו דוגמא אחת לכך:

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

המבחר `Result` הוא גנרי מעל שני טיפוסים, `T` ו-`E`, ויש לו שני וריאנטים: `Ok`, שמאכסן ערך מטיפוס `T`, ו-`Err`, שמאכסן ערך מטיפוס `E`. הגדרה זו הופכת את השימוש במבחר `Result` לנוחה בכל מצב בו יש פעולה שיכולה להצליח (קריא, להחזיר ערך כלשהו מטיפוס `T`) אך עלולה להיכשל (זאת אומרת, להחזיר שגיאה מטיפוס `E`). למעשה, בזה השתמשנו על מנת לפתוח קובץ ברשימה 9-3, ואז `T` הוחלף בטיפוס `std::fs::File` כאשר הקובץ נפתח בהצלחה, בעוד ש-`E` הוחלף בטיפוס `std::io::Error` כאשר ארעה בעיה בפתיחת הקובץ.

כאשר אתם מזהים מצבים בהם הקוד שלכם מכיל כמה הגדרות של מבנים או מבחרים שהשוני היחיד ביניהם הוא בטיפוס הערכים שבהם, תוכלו להימנע מכפילות הקוד על-ידי שימוש בטיפוסים גנרים.

### בהגדרת מתודות

ניתן ליישם מתודות עבור מבנים ומבחרים (כפי שעשינו בפרק 5) ולהשתמש גם בטיפוסים גנרים בהגדרותיהן. רשימה 10-9 מראה את המבנה `Point<T>` שהגדרנו ברשימה 10-6 יחד עם מתודה בשם `x` המיושמת עבורו.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-09/src/main.rs}}
```

<span class="caption">רשימה 10-9: יישום של מתודה בשם `x` על המבנה `Point<T>` המחזירה הפניה מטיפוס `T` לשדה `x`</span>

כאן הגדרנו מתודה בשם `x` עבור `Point<T>` שמחזירה הפניה לערך שבשדה `x`.

שימו לב שיש להכריז על `T` מיד אחרי ה-`impl` כדי שנוכל לציין שאנו מממשים מתודות עבור הטיפוס `.Point<T>` על-ידי הכרזת `T` כטיפוס גנרי אחרי ה-`impl`, ראסט יכולה לזהות שהטיפוס בסוגרים המשולשים ב-`Point` הוא טיפוס גנרי ולא טיפוס קונקרטי. יכולנו לבחור שם שונה עבור פרמטר גנרי זה מהשם של הפרמטר הגנרי שבהגדרת המבנה, אולם נהוג להשתמש באותו שם, למען הנוחות. מתודות שכתובות בתוך בלוק ה-`impl` שמגדיר את הטיפוס הגנרי יהיו קיימות עבור כל מופע של הטיפוס, ללא תלות בטיפוס הקונקרטי שיחליף למעשה את הטיפוס הגנרי.

ניתן גם לציין מגבלות על טיפוסים גנרים כאשר מגדירים מתודות עבורם. נוכל, למשל, ליישם מתודות רק עבור מופעי `Point<f32>` ולא מופעי `Point<T>` עם טיפוס גנרי כללי. ברשימה 10-10 אנו משתמשים בטיפוס הקונקרטי `f32`, זאת אומרת שאנו לא מגדירים אף טיפוס אחרי ה-`impl`.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-10/src/main.rs:here}}
```

<span class="caption">רשימה 10-10: בלוק `impl` שתקף רק למבנה עם טיפוס קונקרטי מסוים עבור פרמטר הטיפוס הגנרי `T`</span>

קוד זה משמעו שלטיפוס `Point<f32>` תהיה מתודה בשם `distance_from_origin`; למופעים אחרים של `Point<T>`, כאשר `T` אינו הטיפוס`f32`, לא תהיה את המתודה הזו. המתודה מודדת את המרחק מהנקודה שלנו לראשית (0.0, 0.0) ומשתמשת בפעולות מתמטיות הזמינות רק עבור נקודות מטיפוס נקודה צפה.

פרמטרי טיפוס גנרים בהגדרה של מבנה אינם תמיד זהים לאלה שבשימוש בחותם המתודות של אותו המבנה. רשימה 10-11 משתמשת בטיפוסים הגנרים `X1` ו-`Y1` עבור המבנה `Point` וב-`X2` ו-`Y2` בחותם המתודה `mixup`, וזאת בכדי להבהיר את הדוגמא. המתודה יוצרת מופע חדש של `Point` בו ערך ה-`x` נלקח מ-`self` (ולכן מטיפוס `X1`) וערך ה-`y` מגיע ממופע ה-`Point` המועבר (ולכן מטיפוס מטיפוס `Y2`).

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-11/src/main.rs}}
```

<span class="caption">רשימה 10-11: מתודה שמשתמשת בטיפוסים גנרים שונים מאלו שבהגדרת המבנה</span>

ב-`main`, הגדרנו מופע של `Point` בעל טיפוס `i32` עבור `x` (עם הערך `5`) ובעל טיפוס `f64` עבור `y` (עם הערך `10.4`). המשתנה `p2` הוא מופע של המבנה `Point` שבו יש חיתוך מחרוזת עבור `x` (עם הערך `"Hello"`) ועם טיפוס `char` עבור `y` (עם הערך `c`). קריאה ל-`mixup` על `p1` עם הארגומנט `p2` מחזירה את `p3`, שבו יש ערך מטיפוס `i32` ב-`x`, כיוון ש-`x` מגיע מ-`p1`. למשתנה `p3` יהיה ערך מטיפוס `char` ב-`y`, כיוון ש-`y` מגיע מ-`p2`. הקריאה למקרו `println!` תדפיס `p3.x = 5, p3.y = c`.

מטרת דוגמא זו היא להציג מצב בו חלק מהפרמטים הגנרים מוכרזים ב-`impl` וחלק מוכרזים בהגדרת המתודה. כאן, הפרמטרים הגנרים `X1` ו-`Y1` מוכרזים אחרי ה-`impl` כיוון שהם חלק מהגדרת המבנה. הפרמטרים הגנרים `X2` ו-`Y2` מוכרזים לאחר ה-`fn mixup`, כיוון שהם רלוונטים רק למתודה.

### יעילות של קוד המשתמש בג'נריקס

אתם בוודאי תוהים האם יש עלות בזמן הריצה כאשר משתמשים בפרמטרי טיפוס גנרים. החדשות הטובות הן ששימוש בטיפוסים גנרים לא יגרום לתכנית שלכם לרוץ לאט יותר מאשר אם הוא היה כתוב עם טיפוסים קונקרטים.

ראסט מצליחה לעשות זאת על ידי ביצוע מונומורפיזציה של הקוד עם הג'נרקיס בזמן הקומפילציה. _מונומורפיזציה_ הוא התהליך של הפיכת קוד גנרי לקוד ספציפי על-ידי החלפת הטיפוסים הגנרים בטיפוסים קונקרטים כחלק מהקומפילציה. בתהליך זה, הקומפילר נוקט בצעדים הפוכים לאלו שאנו נקטנו כאשר יצרנו את הפונקציה הגנרית ברשימה 10-5: הקומפילר מתבונן בכל המקומות בהם קוראים לקוד גנרי ומייצר קוד עבור הטיפוסים הקונקרטים שאיתם קוראים לקוד הגנרי.

הבה נתבונן כיצד תהליך זה מתבצע תוך שימוש במבחר הגנרי `Option<T>` שבספריה הסטנדרטית:

```rust
let integer = Some(5);
let float = Some(5.0);
```

כאשר ראסט מקמפלת את הקוד הזה, היא מבצעת מונומורפיזציה. במהלך תהליך זה, הקומפילר קורא את הערכים בהם השתמשנו במופעי ה-`Option<T>` ומזהה שני סוגים של `Option<T>`: האחד עם `i32` והשני עם `f64`. משכך, הוא מרחיב את ההגדרה הגנרית של `Option<T>` לשתי הגדרות, האחת מותאמת ל-`i32` והשניה ל-`f64`, ובכך מחליף את ההגדרה הגנרית הבודדה בשתי הגדרות ספציפיות.

הגרסה שעברה מונומורפיזציה של הקוד דומה לקוד הבא (הקומפילר משתמש בשמות שונים מאלו המוצגים כאן לצורך הדגמה):

<span class="filename">Filename: src/main.rs</span>

```rust
enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
```

ה-`Option<T>` הגנרי מוחלף בהגדרות הספציפיות שנוצרו על-ידי הקומפילר. כיוון שראסט מקמפלת קוד גנרי לקוד שמציין את הטיפוס בכל מופע, בזמן הריצה אין אנו משלמים כל מחיר עבור השימוש בג'נריקס בקוד שלנו. כאשר הקוד רץ, הוא מתבצע בדיוק באותו אופן כאילו שהקוד היה נכתב ידנית תוך יצירת כפילות קוד. תהליך המונומורפיזציה הופך את השימוש בג'נריקס בראסט ליעיל מאוד בזמן הריצה.
