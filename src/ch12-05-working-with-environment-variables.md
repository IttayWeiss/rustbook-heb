## שימוש במשתני סביבה

נשפר את `minigrep` על-ידי הוספת תכונה נוספת: אופציה לחיפוש קייס סנסיטיב (case sensitive) בה המשתמש יכול לשלוט על-ידי משתנה סביבה. ניתן ליישם יכולת זו כאופציה של כלי שורת הפקודה ולדרוש שמשתמשים ינפיקו אותה בכל פעם שעם עושים בה שימוש, אבל על-ידי זה שבמקום זאת ניישם זאת באמצעות משתנה סביבה נאפשר למשתמשים שלנו לקבוע את משתנה הסביבה פעם אחת ואז כל החיפושים שלהם יהיו קייס סנסיטיב.

### כתיבת מקרה מבחן נכשל למקרה של קייס אינסנסיטיב לפונקציה `search`

תחילה נוסיף פונקציה חדשה, `search_case_insensitive`, שלה נקרא כאשר למשתנה הסביבה יהיה ערך. נמשיך לנקוט בגישת הפמ"ב, כך שהשלב הראשון הוא, שוב, כתיבת מקרה מבחן שנכשל. נוסיף בדיקה נוספת עבור הפונקציה `search_case_insensitive` ונשנה את שם מקרה המבחן הקודם מ-`one_result` ל-`case_sensitive` בכדי להבהיר את ההבדל בין שני מקרי המבחן, כפי שמוצג ברשימה 12-20.

<span class="filename">Filename: src/lib.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-20/src/lib.rs:here}}
```

<span class="caption">רשימה 12-20: הוספת מקרה מבחן כושל נוסף עבור הפונקציה למקרה חיפוש קייס אינסטסיטיב שאנו מתעתדים לכתוב</span>

שימו לב שערכנו גם את ה-`contents` שבמקרה המבחן הישן. הוספנו שורה חדשה עם הטקסט `"Duct tape."` תוך שימוש באות `D` ולכן לא תותאם למחרוזת החיפוש `"duct"` במקרה של חיפוש קייס-סנסיטיב. שינוי מקרה המבחן הישן בצורה זו מסייע להבטיח שלא נשבור בשוגג את פונקציונאליות החיפוש במקרה של קייס-סנסיטיב שכבר מימשנו. מקרה מבחן זה אמור לעבור בהצלחה כעת ואמור להמשיך לעשות זאת בעודנו עובדים על מימוש המקרה של קייס-אינסנסיטיב.

מקרה המבחן החדש למקרה של חיפוש קייס-_אינסנסיטיב_ משתמש ב-`"rUsT"` כמחרוזת החיפוש. בפונקציה `search_case_insensitive` שאנו עומדים להוסיף, מחרוזת החיפוש `"rUsT"` אמורה להתאים לשורה המכילה `"Rust:"` עם האות `R` וכן את השורה `"Trust me."` למרות שאף אחת מהן אינה זהה למחרוזת החיפוש. זהו מקרה המבחן הנכשל שלנו, והוא לא יעבור קומפילציה בגלל שעוד לא הגדרנו את הפונקציה `search_case_insensitive`. הרגישו חופשיים להוסיף שלד של המימוש שתמיד מחזיר וקטור ריק, בדומה למה שעשינו עבור הפונקציה `search` ברשימה 12-16 כדי לראות שהקוד עובר קומפילציה ושהבדיקה אכן נכשלת.

### מימוש הפונקציה `search_case_insensitive`

הפונקציה `search_case_insensitive`, המוצגת ברשימה 12-21, תהיה כמעט זהה לפונקציה `search`. ההבדל היחיד הוא שנעביר לגרסת אותיות קטנות את כל האותיות ב-`query` ובכל `line` כך שללא תלות בהאם האותיות של הפלט גדולות או קטנות, בזמן ההשוואה זה לא ישנה.

<span class="filename">Filename: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-21/src/lib.rs:here}}
```

<span class="caption">רשימה 12-21: הגדרת הפונקציה `search_case_insensitive` תוך העברת האותיות לגרסת אותיות קטנות במחרוזת החיפוש ובכל שורה לפני ביצוע ההשוואה</span>

ראשית, אנו הופכים את כל האותיות במחרוזת `query` לאותיות קטנות ומאכסנים את התוצאה במשתנה מוצלל בעל אותו השם. קריאה ל-`to_lowercase` על מחרוזת החיפוש היא הכרחית כדי להבטיח שלא משנה אם המשתמש הקליד `"rust"`, `"RUST"`, `"Rust"`, או `"rUsT"`, נתייחס למחרוזת החיפוש כאילו היא היתה `"rust"` ובכך נממש התנהגות קייס-אינסנסיטיב.
בעוד `to_lowercase` מטפלת היטב ביוניקוד בסיסי, היא לא מדוייקת במאה אחוז. לו כתבנו אפליקציה אמיתית, היינו רוצים להכניס כאן יותר עבודה, אבל סעיף זה דן במשתני סביבה, לא ביוניקוד, ולכן זהו עיקר הדיון.

שימו לב שכעת `query` הוא מחרוזת ולא חיתוך מחרוזת, בגלל שקריאה ל-`to_lowercase` יוצרת דאטה חדש ולא הפניה לדאטה קיים. נניח, כדוגמא, שמחרוזת החיפוש היא `"rUsT"`: חיתוך מחרוזת זה לא כולל את האותיות `u` או `t`, ולכן חייבים להקצות מופע חדש של `String` שמכיל את הערך `"rust"`. כאשר אנו מעבירים כעת את `query` כארגומנט למתודה `contains`, יש להוסיף את סימן האמפרסנד כי בחותם של `contains` מצויין שהמתודה מקבלת חיתוך מחרוזת.

עכשיו, נוסיף קריאה ל-`to_lowercase` על כל `line` כדי להעביר את כל התווים לאותיות קטנות. עכשיו משהמרנו את `line` ואת `query` לאותיות קטנות, נמצא התאמות ללא תלות בהאם המחרוזת והטקס המקוריים היו אם אותיות גדולות, קטנות, או כל שילוב שהוא.

הבה נראה אם מימוש זה עובר את המבחנים בהצלחה:

```console
{{#include ../listings/ch12-an-io-project/listing-12-21/output.txt}}
```

מצוין! הבדיקות עברו בהצלחה. עכשיו, הבה נקרא לפונקציה החדשה `search_case_insensitive` מתוך הפונקציה `run`. קודם כל, נוסיף אופצית קונפיגורציה למבנה `Config` בכדי להחליף בין חיפושים במצב קייס-סנסיטיב לקייס-אינסנסיטיב.
הוספת שדה זה תגרום לבעיות קומפילציה כיוון שאנו עדיין לא מאתחלים את השדה בשום מקום:

<span class="filename">Filename: src/lib.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-22/src/lib.rs:here}}
```

הוספנו את השדה `ignore_case` שמאכסן ערך בוליאני. כעת, אנחנו צריכים שהפונקציה `run` תבדוק את הערך שבשדה `ignore_case` ותשתמש בו כדי להחליט האם לקרוא לפונקציה `search` או לפונקציה `search_case_insensitive`, כפי שמוצג ברשימה 12-22. הקוד עדיין לא עובר קומפילציה.

<span class="filename">Filename: src/lib.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-22/src/lib.rs:there}}
```

<span class="caption">רשימה 12-22: קריאה ל-`search` או ל-`search_case_insensitive` בהמתאם לערך שב-`config.ignore_case`</span>

לבסוף, יש להשתמש במשתנה הסביבה. הפונקציות לטיפול במשתני סביבה נמצאות במודול `env` בספריה הסטנדרטית, ולכן אנו מכניסים את המודול למתחם בראש הקובץ _src/lib.rs_. ואז נשתמש בפונקציה `var` מהמודול `env` כדי לבדוק אם יש ערך במשתנה סביבה בשם `IGNORE_CASE`, כפי שרואים ברשימה 12-23.

<span class="filename">Filename: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-23/src/lib.rs:here}}
```

<span class="caption">רשימה 12-23: בדיקה אם יש ערך במשתנה סביבה בשם `IGNORE_CASE`</span>

כאן, אנו יוצרים משתנה חדש בשם `ignore_case`. כדי לאכסן בו ערך, אנו קוראים לפונקציה `env::var` ומעבירים אליה את `IGNORE_CASE`, שהוא השם של משתנה הסביבה הרלוונטי. הפונקציה `env::var` מחזירה ערך מטיפוס `Result` שיהיה וריאנט ההצלחה `Ok` שמכיל את הערך במשתנה הסביבה במידה ולמשתנה זה הושם ערך. אם אין ערך במשתנה הסביבה הזה, אז יוחזר וריאנט השגיאה `Err`.

אנו משתמשים במתודה `is_ok` של על ערך ה-`Result` כדי לבדוק אם משתנה הסביבה קיים, ובמקרה זה על התכנית לבצע חיפוש קייס-אינסנסיטיב.
אם משתנה הסביבה `IGNORE_CASE` לא קיים, המתודה `is_ok` תחזיר את הערך ` false` והתכנית תבצע חיפוש קייס-סנסיטיב. הערך עצמו של משתנה הסביבה לא מעניין אותנו, אלה רק אם הושם בו ערך אם לאו, ולכן אנו משתמשים ב- `is_ok` ולא ב-`unwrap`, `expect`, או כל מתודה אחרת עבור `Result` שאולי כבר ראיתם.

אנו מעבירים את הערך שבמשתנה `ignore_case` לתוך מופע ה-`Config` כך שהפונקציה `run` תוכל לקרוא ערך זה ולהחליט האם לקרוא ל-`search_case_insensitive` או ל-`search`, כפי שממומש ברשימה 12-22.

הבה ננסה זאת כעת! ראשית, נריץ את התכנית ללא השמת ערך במשתנה הסביבה ועם מחרוזת החיפוש `to`, שאמורה להתאים כל שורה שכוללת את המילה “to”, באותיות קטנות:

```console
{{#include ../listings/ch12-an-io-project/listing-12-23/output.txt}}
```

נראה שזה עדיין עובד כהלכה! עכשיו, הבה נריץ את התכנית עם הערך `1` מושם למשתנה הסביבה `IGNORE_CASE`, ועדיין עם אותו ערך למחרוזת החיפוש, קריא `to`.

```console
$ IGNORE_CASE=1 cargo run -- to poem.txt
```

אם אתם משתמשים ב-PowerShell, תצטרכו לבצע את ההשמה ואת הרצת התכנית כשתי פקודות נפרדות:

```console
PS> $Env:IGNORE_CASE=1; cargo run -- to poem.txt
```

זה יגרום למשתנה `IGNORE_CASE` להישאר מוגדר עד תום ה-shell session שלכם. ניתן להסיר את הערך באמצעות פקודת `Remove-Item`:

```console
PS> Remove-Item Env:IGNORE_CASE
```

אנו מצפים לקבל שורות שכוללות את המחרוזת “to” בכל צירוף שהוא של אותיות קטנות וגדולות:

<!-- manual-regeneration
cd listings/ch12-an-io-project/listing-12-23
IGNORE_CASE=1 cargo run -- to poem.txt
can't extract because of the environment variable
-->

```console
Are you nobody, too?
How dreary to be somebody!
To tell your name the livelong day
To an admiring bog!
```

מצוין, אכן קיבלנו גם שורות שכוללות את המחרוזת “To”! תכנית ה-`minigrep` יכולה עכשיו לבצע חיפוש קייס-אינסנסיטיב בצורה הנשלטת על-ידי משתנה סביבה. כעת אתם יודעים כיצד לנהל אופציות שנקבעות על-ידי ארגומנטים של שורת הפקודה או על-ידי משתני סביבה.

ישנן תכניות שמאפשרות ארגומנטים _וגם_ משתני סביבה לאותה הקונפיגורציה. בנסיבות כאלה, על התכנית להחליט איזו אופציה מקבלת קדימות. לתרגיל נוסף שתוכלו לעשות בעצמכם, נסו לשלוט בסוג החיפוש לפי או ארגומנט שורת פקודה, או משתנה סביבה. החליטו האם ארגומנט שורת הפקודה או משתנה הסביבה יקבל קדימות במידה והתכנית תורץ כאשר האחד מציין חיפוש קייס-סנסיטיב בעוד השני מציין את ההפך.

המודול `std::env` מכיל יכולות שימושיות רבות נוספות לטיפול במשתני סביבה: בדקו את הדוקומנטציה כדי לגלות מה עוד זמין עבורכם.
