## ארגון מבחנים

כפי שכבר אמרנו בתחילת הפרק, בדיקת קוד היא נושא סבוך, ואנשים שונים נוקטים בטרימינולוגיה ושיטות ארגון שונות. קהילת ראסט חושבת על בדיקות במונחים של שתי קטגוריות מרכזיות: בדיקות יחידה ובדיקות אינטגרציה. _בדיקות יחידה_ הן קצרות וממוקדות, הן בודקות מודול בודד, ויכולות לבדוק ממשקים פרטיים. _בדיקות אינטגרציה_ הן חיצוניות לגמרי לספריה שהן בודקות והן משתמשות בקוד שבו באותה הדרך בה כל קוד חיצוני משתמש בו, תוך שימוש אך ורק בממשק הפומבי, ועשויות לעשות שימוש בכמה מודולים בבדיקה אחת.

כתיבת בדיקות משני סוגים אלה חשובה על מנת להבטיח שפיסות הספריה שלכם עושות מה שאתם מצפים מהם לעשות, כל פיסה לחוד וכל הפיסות יחד.

### בדיקות יחידה

המטרה של בדיקות יחידה היא לבדוק כל יחידת קוד בנפרד משאר הקוד על מנת לזהות במהירות מצבים בהם הקוד אינו עובד כצפוי. ממקמים בדיקות יחידה בספרית ה-_src_ בכל קובץ יחד עם הקוד שהן בודקות. המוסכמה היא ליצור בכל קובץ מודול בשם `tests` שיכיל את פונקציות המבחן ולבאר את המודול עם `cfg(test)`.

#### מודול הבדיקות והביאור `#[cfg(test)]`

הביאור `#[cfg(test)]` על מודול הבדיקות אומר לראסט לקמפל ולהריץ את הקוד רק כאשר מריצים `cargo test`, ולא כאשר מריצים `cargo build`.
בכך חוסכים זמן קומפילציה כאשר מעוניינים רק לבנות את הספריה ומקטינים את גודל תוצאת הקימפול כי הבדיקות אינן כלולות. כפי שתראו, כיוון שבדיקות אינטגרציה ממוקמות בספריה אחרת, אין צורך בביאור `#[cfg(test)]` במקרה זה. אולם, כיוון שבדיקות יחידה נמצאות באותם הקבצים עם הקוד, יש צורך להשתמש ב-`#[cfg(test)]` כדי לציין שאין להכליל אותן בתהליך הקימפול.

זכרו שכאשר יצרנו את הפרויקט `adder` בסעיף הראשון בפרק זה, קארגו יצר עבורנו את הקוד:

<span class="filename">Filename: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-01/src/lib.rs}}
```

קוד זה הוא מודול בדיקה שנוצר אוטומטית. התכונה `cfg` מייצגת _configuration_ ואומרת לראסט שיש להכליל את העצם הבא רק עם אופצית קונפיגורציה מסוימת. במקרה זה, אופצית הקונפיגורציה היא `test`, שמסופקת על-ידי ראסט עבור קימפול והרצת בדיקות. על-ידי שימוש בתכונה `cfg`, קארגו מקמפל את קוד הבדיקה רק אם אנחנו מריצים את הבדיקות עם `cargo test`. זה כולל, בנוסף לפונקציות המבוארות עם `#[test]`, גם כל פונקצית עזר שעשויה להימצא במודול.

#### בדיקת פונקציות פרטיות

יש חוסר הסכמה בקרה קהילת בדיקת קוד אודות האם יש לבדוק פונקציות פרטיות באופן ישיר, ושפות תכנות אחרות הופכות את זה לקשה עד בלתי אפשרי לבדוק פונקציות פרטיות. ללא תלות באידאולוגית הבדיקה בה אתם דבקים, חוקי הפרטיות של ראסט כן מאשפרים בדיקת פונקציות פרטיות.
התבוננו בקוד ברשימה 11-12 המכיל את הפונקציה הפרטית `internal_adder`.

<span class="filename">Filename: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-12/src/lib.rs}}
```

<span class="caption">רשימה 11-12: בדיקת פונקציה פרטית</span>

שימו לב שהפונקציה `internal_adder` לא מסומנת כ-`pub`. בדיקות הן פשוט קוד בראסט, והמודול `tests` הוא פשוט עוד מודול. כפי שהסברנו בסעיף [“מסלולים להפניות לעצמים בעץ המודולים”][paths]<!-- ignore -->, עצמים במודולים יכולים להשתמש בעצמים ממודולי האב שלהם. בבדיקה זו אנו מכניסים את כל העצמים ממודלי האב של `test` למתחם באמצעות `use super::*`, ואז הבדיקה יכולה לקרוא ל-`internal_adder`. אם אינכם סבורים שיש לבדוק פונקציות פרטיות ישירות, אין שום דבר בראסט שיכריח אתכם לעשות זאת.

### מבחני אינטגרציה

בראסט, מבחני אינטגרציה הם חיצוניים לחלוטין לספריה שלכם. מבחנים אלו משתמשים בספריה שלכם בדיוק באותו אופן שכל קוד אחר יעשה זאת, זאת אומרת שהם יכולים לקרוא לפונקציות שמהוות חלק מהממשק הפומבי של הספריה. מטרתם היא לבדוק האם חלקים שונים של הספריה שלכם עובדים יחדיו נכונה. יחידות קוד שעובדות כשורה באופן עצמאי עלולות להיתקל בבעיות כאשר הן מופעלות כחלק ממכלול יותר רחב של קוד, ולכן בדיקות אינטגרציה חשובות בפני עצמן. על מנת ליצור מבחני אינטגרציה, יש ליצור קודם כל תיקיית _tests_.

#### התיקייה _tests_

אנו יוצרים את התיקייה _tests_ ברמה העליונה של תיקיית הפרויקט שלנו, ליד התיקייה _src_. קארגו יודע לחפש קבצי מבחני אינטגרציה בתיקייה זו. ואז ניתן ליצור כמה כבצי מבחן שנרצה, וקארגו יקמפל כל אחד מהקבצים כמכולה נפרדת.

הבה ניצור מבחן אינטגרציה. יחד עם הקוד מרשימה 11-12, עדיין בקובץ _src/lib.rs_, צרו תיקיית _tests_, וצרו קובץ חדש בשם _tests/integration_test.rs_. מבנה התיקייה שלכם צריך להראות כך:

```text
adder
├── Cargo.lock
├── Cargo.toml
├── src
│   └── lib.rs
└── tests
    └── integration_test.rs
```

הקלידו את הקוד מרשימה 11-13 לתוך הקובץ _tests/integration_test.rs_:

<span class="filename">Filename: tests/integration_test.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-13/tests/integration_test.rs}}
```

<span class="caption">רשימה 11-3: מבחן אינטגרציה עבור פונקציה במכולה `adder`</span>

כל קובץ בתיקייה `tests` הוא מכולה נפרדת, ולכן יש להכניס את הספריה שלנו למתחם של כל קובץ מבחן. מסיבה זו אנו מוסיפים את הפקודה `use adder` בראש הקוד, דבר שלא נדרשנו לעשות עם בדיקות יחידה.

אין צורך לבאר עם `#[cfg(test)]` שום פיסת קוד בקובץ _tests/integration_test.rs_. קארגו מתייחס לתיקייה `tests` באופן מיוחד ומקמפל קבצים בתיקייה זו רק כאשר מריצים `cargo test`. כעת, הריצו את הפקודה `cargo test`:

```console
{{#include ../listings/ch11-writing-automated-tests/listing-11-13/output.txt}}
```

שלושת סעיפי הפלט כוללים מבחני יחידה, מבחני אינטגרציה, ומבחני תיעוד. שימו לב שבמידה ומבחן בסעיף כלשהו כושל, הסעיפים הבאים לא יורצו. למשל, אם מבחן יחידה כושל, אז לא יהיה פלא בסעיף של מבחני אינטגרציה או מבחני תיעוד כיוון שמבחנים אלה מורצים רק במידה וכל מבחני היחידה עברו בהצלחה.

הסעיף הראשון עבור מבחני יחידה זהה למה שכבר ראינו: שורה אחת עבור כל מבחן יחידה (אחד מהם בשם `internal` אותו הוספנו ברשימה 11-12) ואז שורת סיכום עבור מבחני היחידה.

סעיף מבחני האינטגרציה מתחיל עם השורה `Running
tests/integration_test.rs`. אחר כך ישנה שורה עבור כל אחת מפונקציות הבדיקה במבחן האינטגרציה ושורת סיכום עבור תוצאות מבחן האינטגרציה, בדיוק לפני שמתחיל הסעיף `Doc-tests adder`.

לכל קובץ של מבחן אינטגרציה יש את הסעיף שלו, כך שאם מוסיפים עוד קבצים בתיקייה _tests_, יתווספו עוד סעיפים במבחן האינטגרציה.

עדיין אפשר להריץ פונקצית מבחן אינטגרציה ספיציפית על-ידי ציון שם הפונקציה כארגומנט ל-`cargo test`. על מנת להריץ את כל הבדיקות במבחן אינטגרציה מסוים, ניתן להעביר ל-`cargo test` את הארגומנט `--test` ולאחריו את שם הקובץ:

```console
{{#include ../listings/ch11-writing-automated-tests/output-only-05-single-integration/output.txt}}
```

פקודה זו תריץ רק את הבדיקות שבקובץ _tests/integration_test.rs_.

#### תת-מודולים במבחני אינטגרציה

ככל שתוסיפו מבחני אינטגרציה, סביר שתרצו להוסיף עוד קבצים בתיקייה _tests_ כדי לעזור לארגן את המבחנים; למשל, תוכלו לקבץ את פונקציות המבחן לפני הפונקציונאליות שהן בודקות. כפי שהוזכר לעיל, כל קובץ בתיקייה _tests_ מקומפל בפני עצמו במכולה משלו, דבר שמייצר מתחמים נפרדים כדי לדמות יותר במדויק את הדרך בה משתמשי קצה ישתמשו בספריה שלכם. אבל, זה גם אומר שקבצים בתיקייה _tests_ לא חולקים את אותה ההתנהגות כמו קבצים ב-_src_, כפי שלמדתם בפרק 7 אודות הפרדת קוד למודולים וקבצים.

ההתנהגות השונה של קבצים בתיקייה _tests_ נהירה במיוחד כאשר יש לכם אוסף של פונקציות עזר לשימוש בכמה קבצי מבחני אינטגרציה ואתם מנסים לעקוב אחד הצעדים מסעיף [“הפרדת מודולים לקבצים נפרדים”][separating-modules-into-files]<!-- ignore --> בפרק 7 על מנת למצות אותם למודול משותף. לדוגמא, אם ניצור את הקובץ _tests/common.rs_ ונמקם בו פונקציה בשם `setup`, נוכל להוסיף קוד כלשהו ל-`setup` שנוכל לקרוא לו מכמה פונקציות מבחן הממוקמות בקבצים שונים:

<span class="filename">Filename: tests/common.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-12-shared-test-code-problem/tests/common.rs}}
```

כאשר נריץ את המבחנים שוב, נראה סעיף חדש בפלט ההרצה עבור הקובץ _common.rs_, למרות שקובץ זה אינו מכיל אף פונקצית בדיקה וגם לא קראנו לפונקציה `setup` בשום צורה:

```console
{{#include ../listings/ch11-writing-automated-tests/no-listing-12-shared-test-code-problem/output.txt}}
```

העובדה ש-`common` מופיע כחלק מתוצאות הבחינות עם המידע `running 0 tests` אינה ההתנהגות אותה רצינו. כל שרצינו היה לחלוק קוד בין קבצי מבחני אינטגרציה.

כדי להימנע מכך ש-`common` יופיע בפלט הבדיקות, במקום הקובץ _tests/common.rs_ ניצור את הקובץ _tests/common/mod.rs_. כעת תיקיית הפרויקט נראית כך:

```text
├── Cargo.lock
├── Cargo.toml
├── src
│   └── lib.rs
└── tests
    ├── common
    │   └── mod.rs
    └── integration_test.rs
```

כאן נעשה שימוש במוסכמת מתן השמות הישנה שגם אותה ראסט מבינה, כפי שהזכרנו בסעיף [“מסלולי קבצים אלטרנטיבים”][alt-paths]<!-- ignore --> בפרק 7. מתן שם קובץ זה אומר לראסט לא להתייחס למודול `common` כמבחן אינטגרציה. כאשר מעבירים את הקוד של הפונקציה `setup` לקובץ _tests/common/mod.rs_ ומוחקים את הקובץ _tests/common.rs_, הסעיף בפלט הרצת הבחינות מפסיק להופיע. קבצים בתתי-תיקיות של התיקייה _tests_ לא עוברים קומפילציה כמכולות נפרדות ולא מופיעים בפלט הרצת הבחינות.

לאחר יצירת הקובץ _tests/common/mod.rs_, ניתן להשתמש בו כמודול מכל קובץ של מבחן אינטגרציה. הינה דוגמא לקריאה לפונקציה `setup` מתוך פונקציה המבחן `it_adds_two` שבקובץ _tests/integration_test.rs_:

<span class="filename">Filename: tests/integration_test.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-13-fix-shared-test-code-problem/tests/integration_test.rs}}
```

שימו לב ההכרזה `mod common;` היא כמו הכרזת המודול שהצגנו ברשימה 7-21. אז ניתן לקרוא לפונקציה `common::setup()` מתוך פונקצית המבחן.

#### מבחני אינטגרציה למכולות בינאריות

במידה והפרויקט שלנו הוא מכולה בינארית שמכילה קובץ _src/main.rs_ ללא קובץ _src/lib.rs_, לא ניתן לכתוב מבחני אינטגרציה בתיקיה _tests_ ולהכניס למתחם באמצעות פקודת `use` פונקציות המוגדרות בקובץ _src/main.rs_. רק מכולות ספריה יכולות לחשוף פונקציות לשימוש מכולות אחרות; מכולות בינאריות אמורות לרוץ בפני עצמן.

זו אחת הסיבה לכך שלפרוייקטי ראסט שמייצרים קובץ בינארי יש קובץ _src/main.rs_ פשוט מאוד שקורא לקוד שחי בקובץ _src/lib.rs_. תוך שימוש במבנה כזה, _כן_ ניתן לכתוב פונקציות אינטגרציה שבודקות את ספריהת המכולה ולהשתמש בפקודת `use` על מנת להנגיש פונקציונאליות חשובה.
אם הפונקציונאליות החשובה עובדת כהלכה, הקוד המינימלי שבקובץ _src/main.rs_ עובד גם כן, ופיסת קוד קצרה זו לא דורשת בדיקות.

## סיכום

יכולות הבדיקה של ראסט מספקות דרך לציין כיצד קוד אמור להתנהג כדי לוודא שהוא ממשיך לעבוד כצפוי, אפילו תחת שינויים. בדיקות יחידה משתמשות בנפרד בחלקים שונים של הספריה ויכולות לבדוק פרטי מימושים פרטיים. בדיקות אינטגרציה בודקות שחלקים שונים של הספריה עובדים יחדיו בצורה נכונה, והן משתמשות בממשק הפומבי של הספריה על מנת לבדוק את הקוד תוך שימוש בו באותו אופן בו קוד חיצוני יעשה בו שימוש. למרות שמערכת הטיפוסים של ראסט וכללי הבעלות עוזרים למנוע סוגים מסויימים של באגים, פונקציות מבחן עדיין משחקות תפקיד חשוב בהפחתת שגיאות לוגיות שנובעות מכך שהקוד שלנו לא מתנהג כפי שאנו מצפים.

הבה נשלב את הידע שצברתם בפרק זה ובפרקים הקודמים ונעבור לעבוד על פרוייקט!

[paths]: ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html
[separating-modules-into-files]: ch07-05-separating-modules-into-different-files.html
[alt-paths]: ch07-05-separating-modules-into-different-files.html#alternate-file-paths
