## קבלת ארגומנטים בשורת הפקודה

הבה ניצור פרוייקט, כרגיל, באמצעות `cargo new`. נקרא לפרוייקט שלנו `minigrep` על מנת להבדיל בינו לבין הכלי `grep` שוודאי כבר מותקן במערכת שלכם.

```console
$ cargo new minigrep
     Created binary (application) `minigrep` project
$ cd minigrep
```

המטרה הראשונה היא לאפשר ל-`minigrep` לקבל את שני הארגומנטים שלו משורת הפקודה: מסלול הקובץ והמחרוזת שיש לחפש. זאת אומרת, אנחנו רוצים להיות מסוגלים להריץ את התכנית שלנו עם `cargo run`, שני מקפים כדי לציין שהארגומנטים הבאים הם עבור התכנית שלנו, ולא עבור `cargo`, ואז מחרוזת לחיפוש, ומסלול לקובץ בו יש לחפש, בצורה הבאה:

```console
$ cargo run -- searchstring example-filename.txt
```

בשלב זה, התכנית ש-`cargo new` יצר לא יכולה לעבד ארגומנטים המועברים אליה. ישנן ספריות קיימות ב-[crates.io](https://crates.io/) שיכולות לעזור בכתיבת תכנית שמקבלת ארגומנטים משורת הפקודה, אבל כיוון שאנו רק לומדים את המושג, הבה נממש יכולת זו בעצמנו.

### קריאת ערכי הארגומנטים

על מנת לאפשר ל-`minigrep` לקרוא ערכים מארגומנטים המועברים בשורת הפקודה, נזדקק לפונקציה `std::env::args` מהספריה הסטנדרטית. פונקציה זו מחזירה איטרטור של הארגומנטים שהועברו בשורת הפקודה ל-`minigrep`. נערוך דיון מלא אודות איטרטורים [בפרק 13][ch13]<!-- ignore
-->. לעת עתה, עליכם לדעת רק שני פרטים אודות איטרטורים: איטרטורים יוצרים סדרת ערכים, וניתן לקרוא למתודה `collect` על איטרטור על מנת להפוך אותו לאוסף, כמו ווקטור, שמכיל אל כל האלמנטים שהאיטרטור מייצר.

הקוד ברשימה 12-1 מאפשר לתכנית ה-`minigrep` לקרוא ארגומנטים משורת הפקודה המועברים אליה, ואז לאסוף את הערכים כווקטור.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-01/src/main.rs}}
```

<span class="caption">רשימה 12-1: איסוף הארגומנטים משורת הפקודה כווקטור, והדפסתם</span>

ראשית, אנו מכניסים את המודול `std::env` למתחם באמצעות פקודת `use` כדי שנוכל להשתמש בפונקציה `args` שבמודול זה. שימו לה כי הפונקציה `std::env::args` מקוננת בתוך שתי רמות במודול. כפי שדנו [בפרק
7][ch7-idiomatic-use]<!-- ignore -->, במקרים בהם הפונקציה הרצויה מקוננת ביותר ממודול אחד, בחרנו להכניס את מודול האב למתחם, ולא את הפונקציה. בכך אנו יכולים בנקל להשתמש בפונקציות אחרות המצויות ב-`std::env`. כמו כן, הכנסת `use std::env::args` למתחם, ואז קריאה לפונקציה רק על-ידי `args`, תפגם בקריאות, שכן אז פחות ברור שהקריאה היא לפונקציה ממודול ולא לפונקציה המוגדרת מקומית.

> ### הפונקציה `args` ויוניקוד שגוי
>
> שימו לב ש-`std::env::args` תיכנס לפאניקה במידה ואחד הארגומנטים יהיה יוניקוד שגוי. אם התכנית שלכם צריכה לקבל ארגומנטים שכוללים יוניקוד שגוי, השתמשו ב-`std::env::args_os` במקום. פונקציה זו מחזירה איטרטור שמייצר ערכי `OsString` במקום ערכי `String`. אנו בחרנו כאן להשתמש ב-`std::env::args`, כיוון שערכי `OsString` הם תלויי מערכת וקשה יותר לעבוד איתם בהשוואה לערכי `String`.

בשורה הראשונה של הפונקציה `main`, אנו קוראים ל-`env::args`, ומייד משתמשים ב-`collect` על מנת להפוך את האיטרטור לווקטור שמכיל את כל הערכים שהאיטרטור מספק. ניתן להשתמש בפונקציה `collect` בכדי ליצור כל מיני סוגים של אוספים, ולכן אנו מבארים מפורשות את הטיפוס של `args` בכדי לציין שאנו מעוניינים בווקטור של מחרוזות. למרות שרק לעיתים נדירות נצטרך לבאר טיפוסים בראסט, הפונקציה `collect` היא פונקציה שדורשת ביאורים במקרים רבים בגלל שראסט לא יכולה להסיק איזה סוג אוסף אנו רוצים.

לבסוף, אנו מדפיסים את הווקטור באמצעות מאקרו. הבה ננסה להריץ את הקוד, ראשית ללא ארגומנטים ואחר-כך עם שני ארגומנטים:

```console
{{#include ../listings/ch12-an-io-project/listing-12-01/output.txt}}
```

```console
{{#include ../listings/ch12-an-io-project/output-only-01-with-args/output.txt}}
```

שימו לב שהערך הראשון בווקטור הוא `"target/debug/minigrep"`, שהוא שם הקובץ הבינארי שלנו. התנהגות זו תואמת את זו של רשימת הארגומנטים ב-C, המאפשרת לתכניות להשתמש בשם שהריץ את התכנית.
זה נוח לעיתים שיש גישה לשם התכנית במקרה שרוצים להדפיס אותו בהודעות או לשנות את התנהגות התכנית בהתאם לפקודה שהריצה את התכנית. אבל, למטרות פרק זה, נתעלם מכך ונשמור רק את שני הארגומנטים שאנחנו צריכים.

### שמירת ערכי הארגומנטים במשתנים

כרגע, התכנית יכולה לגשת לערכים המועברים כארגומנטים בשורת הפקודה. עכשיו אנחנו צריכים לשמור את הערכים של שני הארגומנטים במשתנים כדי שנוכל להשתמש בערכים במהלך התכנית. אנו עושים זאת ברשימה 12-2.

<span class="filename">Filename: src/main.rs</span>

```rust,should_panic,noplayground
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-02/src/main.rs}}
```

<span class="caption">רשימה 12-2: יצירת משתנים כדי לאכסן את ארגומנט החיפוש וארגומנט מסלול הקובץ</span>

כפי שראינו כאשר הדפסנו את הווקטור, שם התכנית ממוקם במיקום הראשון בווקטור, זאת אומרת ב-`args[0]`, ולכן אנו מתחילים באינדקס 1. הארגומנט הראשון ש-`minigrep` מקבלת הוא מחרוזת החיפוש, ולכן אנו שומרים הפניה לארגומנט הראשון במשתנה `query`. הארגומנט השני הוא מסלול הקובץ, ולכן אנו שומרים הפניה לארגומנט השני במשתנה `file_path`.

אנו מדפיסים, באופן זמני, את ערכי המשתנים כדי להיווכח שהקוד עובד כמצופה. הבה נריץ תכנית זו שוב, הפעם עם הארגומנטים `test` ו-`sample.txt`:

```console
{{#include ../listings/ch12-an-io-project/listing-12-02/output.txt}}
```

נפלא, התכנית עובדת! הערכים של הארגומנטים שאנחנו צריכים מאוכסנים לתוך המשתנים הנכונים. מאוחר יותר נוסיף טיפול בשגיאות כדי להתמודד עם מצבי שגיאה פוטנציאלים, למשל מצב בו המשתמש לא מספק ארגומנטים; לבינתיים, נתעלם ממצב זה ונעבוד במקום זאת על הוספת יכולות לקריאת קובץ.

[ch13]: ch13-00-functional-features.html
[ch7-idiomatic-use]: ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#creating-idiomatic-use-paths
