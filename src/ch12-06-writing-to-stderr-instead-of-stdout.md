## כתיבת הודעות שגיאה לזרם השגיאות הסטנדרטי במקום לזרם הפלט הסטנדרטי

בשלב זה, אנחנו כותבים את כל הפלט לטרמינל תוך שימוש במקרו `println!`. ברוב הטרמינלים יש שני סוגים של פלט: _זרם הפלט הסטנדרטי_ (`stdout`) עבור מידע כללי _וזרם השגיאות הסטנדרטי_ (`stderr`) עבור הודעות שגיאה. הבחנה זו מאפשרת למשתמשים לבחור להכווין את פלט התכנית הקשור להצלחות לשמירה בקובץ, ועדיין להדפיס את הודעות השגיאה למסך.

המקרו `println!` תמיד מדפיס לזרם הפלט הסטנדרטי, ולכן, כדי להדפיס לזרם השגיאות הסטנדרטי, עלינו להשתמש בכלי אחר.

### בדיקת מיקום כתיבת הודעות השגיאה

ראשית, הבה נראה כיצד התוכן המודפס על-ידי `minigrep` במצבו הנוכחי מודפס לזרם הפלט הסטנדרטי, כולל הודעות שגיאה שנרצה לכתוב במקום זאת לזרם השגיאות הסטנדרטי. נעשה זאת על-ידי הכוונת זרם הפלט הסטנדרטי לקובץ וניצור שגיאה בכוונה. אנחנו לא מכווינים את זרם השגיאות הסטנדרטי, ולכן כל תוכן שיישלך לזרם השגיאות הסטנדרטי ימשיך להופיע על המסך.

מצופה מתכניות שורת פקודה לשלוח הודעות שגיאה לזרם השגיאות הסטנדרטי כדי שאפשר יהיה לראות הודעות שגיאה על המסך אפילו אם מכווינים את זרם הפלט הסטנדרטי לקובץ. התכנית שלנו, כרגע, לא מתנהגת בהתאם: אנו עומדים לראות שהיא שומרת את הודעות השגיאה לקובץ!

כדי להדגים התנהגות זו, נריץ את התכנית עם הסימן `>` ומסלול הקובץ _output.txt_, אליו אנו מפנים את זרם הפלט הסטנדרטי. לא נעביר ארגומנטים, ובכל ניצור שגיאה:

```console
$ cargo run > output.txt
```

התחביר `>` מנחה את המעטפת לכתוב את תוכן זרם הפלט הסטנדרטי לקובץ _output.txt_ במקום למסך. על מסך המחשב לא ראינו את הודעת השגיאה לה ציפינו, והמשמעות היא שהיא מצאה את דרכה אל הקובץ. הינה התוכן של _output.txt_:

```text
Problem parsing arguments: not enough arguments
```

אכן, הודעת השגיאה מודפבת לזרם הפלט הסטנדרטי. הרבה יותר מועיל אם הודעות שגיאה כאלה יודפסו לזרם השגיאות הסטנדרטי כדי שרק דאטה מפעולות מוצלחות של התכנית ימצאו את דרכן לקובץ. וזאת נעשה.

### הדפסת שגיאות לזרם השגיאות הסטנדרטי

נשתמש בקוד שברשימה 12-24 כדי לשנות את הדרך בה הודעות שגיאה מודפסות.
בעקבות הארגון מחדש שביצענו בשלב קודם בפרק, כל הקוד האחראי על הדפסת הודעות שגיאה נמצא בפונקציה אחת ויחידה, והיא הפונקציה `main`. הספריה הסטנדרטית מספקת את המקרו `eprintln!` שמדפיס לזרם השגיאות הסטנדרטי, ועל כן, נשתמש בשני המקומות הקוראים ל-`println!` ב-`eprintln!`.

<span class="filename">Filename: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-24/src/main.rs:here}}
```

<span class="caption">רשימה 12-24: כתיבת הודעות שגיאה לזרם השגיאות הסטנדרטי תוך שימוש במקרו `eprintln!`</span>

הבה נריץ שוב את התכנית באותה הצורה, ללא ארגומטים ועם הפניית זרם הפלט הסטנדרטי לקובץ:

```console
$ cargo run > output.txt
Problem parsing arguments: not enough arguments
```

כעת אנו רואים את הודעת השגיאה על המסך והקובץ _output.txt_ אינו מכיל דבר, וזו ההתנהגות המצופה מתכניות שורת פקודה.

בואו נריץ את התכנית פעם נוספת, אך הפעם עם ארגומנטים שלא יוצרים שגיאה, ועדיין עם הפניית זרם הפלט הסטנדרטי לקובץ, בצורה זאת:

```console
$ cargo run -- to poem.txt > output.txt
```

הפעם לא נראה שום פלט על המסך, והקובץ _output.txt_ יכיל את התוצאות:

<span class="filename">Filename: output.txt</span>

```text
Are you nobody, too?
How dreary to be somebody!
```

זה מדגים שעכשיו אנחנו משתמשים בזרם הפלט הסטנדרטי עבור פלט שנובע מהצלחות ובזרם השגיאות הסטנדרטי עבור פלט שנובע משגיאות, וזאת בדיוק ההתנהגות הרצויה.

## סיכום

פרק זה נגע בכמה מושגים מרכזיים שלמדתם עד כה והראה כיצד לבצע פעולות I/O שכיחות בראסט. על-ידי שימוש בארגומנטי שורת פקודה, קבצים, משתני סביבה, והמקרו `eprintln!` עבור הדפסת שגיאות, כעת אתם מוכנים לפתח אפליקציות שורת פקודה. בשילוב עם מושגים מפרקים קודמים, הקוד שלכם יהיה מאורגן היטב, יאכסן דאטה בצורה יעילה במבני נתונים מתאימים, יטפל בשגיאות בצורה נאותה, ויפותח תוך אבטחת נכונות באמצעות בדיקות.

הנושא הבא עוסק בכמה יכולות של ראסט שהושפעו על-ידי שפות פונקציונאליות: סגורים ואיטרטורים.
