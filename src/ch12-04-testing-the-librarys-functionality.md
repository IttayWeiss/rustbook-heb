## פיתוח הפונקציונאליות של הספריה עם פיתוח מונחה-בדיקות

עכשיו משמיצינו את הלוגיקה לקובץ _src/lib.rs_ והשארנו את איסוף הארגומנטים והטיפול בשגיאות בקובץ _src/main.rs_, הרבה יותר פשוט לכתוב מקרי מבחן לפונקציונאליות הגרעינית של הקוד. ניתן לקרוא ישירות לפונקציות עם כל מיני ארגומנטים ולבדוק את הערכים המוחזרים ללא צורך לקרוא לקובץ הבינרי משורת הפקודה.

בסעיף זה, נוסיף לתכנית `minigrep` את הלוגיקה של החיפוש תוך שימוש בתהליך של פיתוח מונחה-בדיקות (פמ"ב) לפני הצעדים הבאים:

1. כתיבת מקרה מבחן שנכשל והרצתו על מנת לוודא שהוא נכשל מהסיבה הצפויה.
2. כתיבת או עדכון מינימלי של קוד כדי לאפשר למקרה המבחן לעבור.
3. ארגון מחדש של הקוד החדש ווידוא שהוא עדיין עובר את המבחן.
4. חזרה לצעד הראשון!

פמ"ב הוא דרך אחת מיני רבות לכתיבת קוד, והוא יכול לסייע בהנעת תהליך תכנון הקוד. כתיבת מקרי המבחן לפני שכותבים את הקוד עצמו מסייעת לתחזק מקרי מבחן שמכסים מגוון התנהגויות במהלך התהליך.

אנו נפתח את הפונקציונאליות של חיפוש המחרוזת בתוכן הקובץ והפקת רשימת השורות שמכילות אותה בשיטת פמ"ב. נוסיף פונקציונאליות זו בפונקציה שנקראת `search`.

### כתיבת מקרה מבחן שנכשל

כיוון שאין לנו בהם יותר צורך, הבה נסיר את פקודות ה-`println!` מהקבצים _src/lib.rs_ ו-_src/main.rs_ בהן השתמשנו כדי לבדוק את התנהגות התכנית.
אז, בקובץ _src/lib.rs_, נוסיף מודול בשם `tests`, כפי שעשינו [בפרק 11][ch11-anatomy]<!-- ignore -->. פונקצית הבדיקה מציינת את ההתנהגות שאנו רוצים שתהיה לפונקציה `search`: היא מקבלת מחרוזת חיפוש ואת הטקסט לחפש בו, ומחזירה רק את השורות מהטקסט שמכילות את מחרוזת החיפוש. רשימה 12-15 מראה בדיקה זו, שעדיין לא עוברת קומפילציה.

<span class="filename">Filename: src/lib.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-15/src/lib.rs:here}}
```

<span class="caption">רשימה 12-15: יצירת מקרה מבחן שנכשל הבודק את הפונקציה `search`</span>

בדיקה זו מחפשת את המחרוזת `"duct"`. הטקסט בו אנו מחפשים מורכב משלוש שורות, ורק אחת מהן מכילה את הצירוף `"duct"` (שימו לב שהלוכסן האחורי שאחרי הגרשיים הפותחים מציין לראסט שלא לשים שורה חדשה בתחילת התוכן של מחרוזת מפורשת זו). אנו קובעים שהערך המוחזר מהפונקציה `search` מכיל רק את השורה לה אנו מצפים.

עוד אין ביכולתנו להריץ מבחן זה ולראות שהוא נכשל מכיוון שהקוד לא עובר קומפילציה: הפונקציה `search` כלל אינה קיימת! בהתאם לעקרונות פמ"ב, נוסיף רק את כמות הקוד המינימלית הדרושה כדי לקמפל ולהריץ, וזאת על-ידי הוספת הגדרה של פונקצית ה-`search` שתמיד מחזירה וקטור ריק, כפי שרואים ברשימה 12-16. כך הבדיקה תעבור קומפילציה ותכשל היות והוקטור הריק אינו תואם וקטור שמכיל את השורה `"safe,
fast, productive."`

<span class="filename">Filename: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-16/src/lib.rs:here}}
```

<span class="caption">רשימה 12-16: הגדרה מינימלית של הפונקציה `search` רק בשביל לעבור קומפילציה</span>

שימו לב שיש להגדיר את משך-החיים המפורש `'a` בחותם של `search` ולהשתמש במשך-חיים זה עבור הארגומנט `contents` ועבור הערך המוחזר. זכרו [מפרק 10][ch10-lifetimes]<!-- ignore --> שפרמטרי משך-חיים מציינים כיצד משכי-החיים של הארגומנטים קשורים למשך-החיים של הערך המוחזר. במקרה זה אנו מציינים שהוקטור המוחזר צריך להכיל חיתוך מחרוזת שמפנה לחיתוכים של הארגומנט `contents` (ולא של הארגומנט `query`).

במילים אחרות, אנו אומרים לראסט שהדאטה שמוחזר מהפונקציה `search` יחיה אותו זמן כמו הדאטה שמועבר לתוך הפונקציה `search` בארגומנט `contents`. זה חשוב! הדאטה שמופנה _על-ידי_ חיתוך חייב להיות תקף על מנת שההפניה תהיה תקפה; אם הקומפיילר יניח שאנו עובדים עם חיתוכי מחרוזות של `query` במקום `contents`, הוא יבצע את בדיקות הבטיחות שלו באופן שאינו תואם את צרכנו.

במידה ונשכח לבאר את משך-החיים וננסה לקמפל את הפונקציה, נקבל את השגיאה הבאה:

```console
{{#include ../listings/ch12-an-io-project/output-only-02-missing-lifetimes/output.txt}}
```

ראסט לא יכולה לדעת איזה משני הארגומנטים אנו צריכים, ולכן יש לציין זאת מפורשות. בגלל ש-`contents` הוא הארגומנט שמכיל את כל הטקסט שלנו ואנחנו מעוניינים להחזיר את החלקים של הטקסט שתואמים את מחרוזת החיפוש, אנו יודעים ש-`contents` הוא הארגומנט שצריך להיות מקושר לערך המוחזר, תוך שימוש בתחביר משך-חיים.

שפות תכנת אחרות לא דורשות לקשר ארגומנטים של פונקציות לערך המחוזר של הפונקציה, אבל ביצוע פעולה זו יהפוך לפשוט יותר עם הזמן. אולי תרצו בשלב זה להשוות דוגמא זו עם סעיף [“וידוא הפניות באמצעות משך-חיים”][validating-references-with-lifetimes]<!-- ignore --> בפרק 10.

כעת, הבה נריץ את מקרה המבחן:

```console
{{#include ../listings/ch12-an-io-project/listing-12-16/output.txt}}
```

מצוין, הבדיקה נכשלת, בדיוק כפי שציפינו. משימתנו כעת היא לגרום לה לעבור בהצלחה!

### כתיבת קוד כדי לעבור בהצלחה את הבדיקה

בשלב זה, הבדיקה שלנו נכשלת בגלל שאנחנו תמיד מחזירים וקטור ריק. בכדי לתקן זאת ולממש את `search`, על התכנית שלנו לבצע את הפעולות הבאות:

- מעבר על כל אחת משורות התוכן של הטקסט.
- בדיקה האם השורה מכילה את מחרוזת החיפוש.
- במידה וכן, הוספת השורה לרשימת הערכים שאנו מחזירים.
- במידה ולא, לא לעשות דבר.
- החזרת רשימת התואצות שתואמות את מחרוזת החיפוש.

הבה נבצע כל צעד, ונתחיל עם איטרציה על השורות.

#### איטרציה על השורות באמצעות המתודה `lines`

בראסט יש מתודה שימושית, שנקראת `lines`, לטיפול באיטרציות שורה-אחר-שורה של מחרוזות, והיא עובדת כפי שמוצג ברשימה 12-17. שימו לב שקוד זה לא עובר קומפילציה.

<span class="filename">Filename: src/lib.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-17/src/lib.rs:here}}
```

<span class="caption">רשימה 12-17: איטרציה על כל השורות ב-`contents`</span>

המתודה `lines` מחזירה איטרטור. נדון באיטרטורים [בפרק 13][ch13-iterators]<!-- ignore -->, אולם זכרו שכבר ראיתם דרך זו לשימוש באיטרטורים [ברשימה 3-5][ch3-iter]<!-- ignore -->, שם השתמשנו בלולאת `for` עם איטרטור כדי להריץ קוד מסוים על כל אלמנט באוסף.

#### חיפוש מחרוזת החיפוש בכל שורה

הצעד הבא הוא לבדוק האם השורה הנוכחית מכילה את מחרוזת החיפוש.
למרבה המזל, למחרוזות יש את המתודה `contains` שעושה בדיוק את זה! על כן, נוסיף בתוך הפונקציה `search` קריאה למתודה `contains`, כמוצג ברשימה 12-18. שימוש לב שהקוד עדיין לא עובר קומפילציה.

<span class="filename">Filename: src/lib.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-18/src/lib.rs:here}}
```

<span class="caption">רשימה 12-18: הוספת פנקציונאליות כדי לבדוק האם השורה מכילה את המחרוזת `query`</span>

ברגע זה, אנו משדרגים את הפונקציונאליות. כדי לאפשר לקוד לעבור קומפילציה, יש להחזיר ערך מגוף הפונקציה כפי שציינו בחותם הפונקציה שנעשה.

#### אכסון שורות תואמות

כדי לסיים את כתיבת הפונקציה, עלינו למצוא דרך לאכסן את השורות התואמות שברצוננו להחזיר. לשם כך, נוכל ליצור וקטור בר-שינוי לפני לולאת ה-`for` ולקרוא למתודה `push` כדי לאכסן את `line` בוקטור. אחרי לולאת ה-`for` נחזיר את הוקטור, כפי שמוצג ברשימה 12-19.

<span class="filename">Filename: src/lib.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-19/src/lib.rs:here}}
```

<span class="caption">רשימה 12-19: אכסון השורות התואמות כדי שנוכל להחזירן</span>

כעת הפונקציה `search` צריכה להחזיר רק את השורות שמכילות את `query`, ומקרה המבחן שלנו צריכה לעבור בהצלחה. הבה נריץ אותה:

```console
{{#include ../listings/ch12-an-io-project/listing-12-19/output.txt}}
```

הבדיקה עברה בהצלחה, כך שאנחנו יכולים בלב שלם להכריז על הצלחה!

בנקודה זו, ניתן לשקול הזדמנויות לארגון מחדש של המימוש של פונקצית החיפוש בעוד אנו מוודאים שמקרי המבחן ממשיכים לעבור וכך לוודא שהפונקציונאליות נשמרת. הקוד בפונקצית החיפוש אינו רע, אבל הוא לא מנצל כמה תכונות שימושיות של איטרטורים. נחזור לדוגמא זו [בפרק 13][ch13-iterators]<!-- ignore -->, שם נלמד על איטרטורים ביתר פירוט, ונראה כיצד לשפר את הקוד הנוכחי.

#### שימוש בפונקציה `search` מתוך הפונקציה `run`

עכשיו שהפונקציה `search` עובדת ועברה את מקרה המבחן שלנו, יש לקרוא ל-`search` מתוך הפונקציה `run`. צריך להעביר לפונקציה `search` את ערך ה-`config.query` ואת המשתנה `contents` ש-`run` קרא מהקובץ. הפונקציה `run` תדפיס כל שורה שמחוזרת מ-`search`:

<span class="filename">Filename: src/lib.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/no-listing-02-using-search-in-run/src/lib.rs:here}}
```

אנחנו עדיין משתמשים בלולאת `for` כדי להחזיר כל שורה מ-`search` ולהדפיס אותה.

כעת כל התכנית אמורה לעבוד! הבה ננסה, ראשית עם מילה שאמורה להחזיר בדיוק שורה אחת מהשיר אל אמילי דיקינסון, המילה “frog”:

```console
{{#include ../listings/ch12-an-io-project/no-listing-02-using-search-in-run/output.txt}}
```

אחלה! כעת ננסה עם מילה שאמורה להתאים לכמה שורות, כמו המילה “body”:

```console
{{#include ../listings/ch12-an-io-project/output-only-03-multiple-matches/output.txt}}
```

ולבסוף, נוודא שעבור מילה שלא מופיע בשיר כלל אנחנו אכן לא מקבלים שום שורות מותאמות, כמו עבור המילה “monomorphization”:

```console
{{#include ../listings/ch12-an-io-project/output-only-04-no-matches/output.txt}}
```

מצוין! בנינו גרסת זעיר-ענפין משלנו לכלי קלאסי ולמדנו רבות אודות עיצוב אפליקציות. כמו כן, למדנו מעט אודות קלט מקבצים, פלט, משכי-חיים, מקרי מבחן, ופארסינג משורת הפקודה.

כדי לסיים את הפרוייקט, נדגים בקצרה כיצד לעבוד עם משתני סביבה וכיצד להדפיס לזרם השגיאות הסטנדרטי, שני אספקטים שימושיים כאשר כותבים תכניות שורת פקודה.

[validating-references-with-lifetimes]: ch10-03-lifetime-syntax.html#validating-references-with-lifetimes
[ch11-anatomy]: ch11-01-writing-tests.html#the-anatomy-of-a-test-function
[ch10-lifetimes]: ch10-03-lifetime-syntax.html
[ch3-iter]: ch03-05-control-flow.html#looping-through-a-collection-with-for
[ch13-iterators]: ch13-02-iterators.html
