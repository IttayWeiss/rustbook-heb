## מסלולים להפניה לפריט בתוך עץ המודולים

כדי להראות לראסט היכן נמצא עצם מסויים בעץ המודולים, ניתן להשתמש במסלול באותו כמו בעת ניווט מערכת הקבצים. בכדי לקרוא לפונקציה, עלינו לדעת את המסלול אליה.

מסלול יכול להופיע באחת משתי צורות:

- _מסלול אבסולוטי_ הוא המסלול המלא, החל ממכולת הבסיס; עבור קוד ממכולה חיצונית, המסלול המלא מתחיל בשם המכולה, ועבור קוד מהמכולה הנוכחית, שם המסלול מתחיל במילה `crate`.
- _מסלול יחסי_ מתחיל מהמודול הנוכחי ומשתמש ב- `self`, `super`, או מציין כלשהו במודול הנוכחי.

במסלולים אבסולוטיים ויחסיים כאחד משתמשים במציינים המופרדים ע"י נקודותיים כפולות (`::`).

הבה נחזור לרשימה 7-1, ונניח שאנו רוצים לקרוא לפונקציה `add_to_waitlist`. עלינו לענות על השאלה: מהו המסלול אל הפונקציה `add_to_waitlist`? רשימה 7-3 מכילה את תוכן רשימה 7-1 (בהשמטת כמה פונקציות ומודולים).

נראה שתי דרכים לקרוא לפונקציה `add_to_waitlist` מתוך הפונקציה החדשה `eat_at_restaurant` שמוגדרת בבסיס המכולה. מסלולים אלה נכונים, אבל נותרה בעיה אחת שמונעת מדוגמה זו מלעבור קומפילציה כמו שהיא כעת. נסביר מדוע בעוד כמה רגעים.

הפונקציה `eat_at_restaurant` היא חלק מה-API של מכולת הספריה שלנו, ולכן אנו מסמנים אותה במילת המפתח `pub`. בסעיף ["חשיפת מסלולים באמצעות מילת המפתח `pub`"][pub]<!-- ignore --> , נדון בפירוט בשימוש ב-`pub`.

<span class="filename">Filename: src/lib.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-03/src/lib.rs}}
```

<span class="caption">רשימה 7-3: קריאה לפונקציה `add_to_waitlist` תוך שימוש במסלולים אבסולוטיים</span>

בפעם הראשונה בה אנו קוראים לפונקציה `add_to_waitlist` ב- `eat_at_restaurant`, אנו משתמשים במסלול אבסולוטי. הפונקציה `add_to_waitlist` מוגדרת באותה המכולה כמו `eat_at_restaurant`, ולכן ניתן להשתמש במילת המפתח `crate` כתחילת המסלול. לאחר מכן, אנו משרשרים את שמות המודולים בעודנו עושים את דרכנו אל `add_to_waitlist`. תוכלו לדמיין מערכת קבצים עם אותו המבנה: נציין את המסלול `/front_of_house/hosting/add_to_waitlist` כדי להריץ את התכנית `add_to_waitlist`; שימוש בשם `crate` כדי לציין את בסיס המכולה כנקודת ההתחלה שקול לשימוש מתוך המעטפת (shell) ב- `/` בכדי לציין את בסיס מערכת הקבצים כנקודת ההתחלה.

בפעם השניה בה אנו קוראים ל-`add_to_waitlist` ב-`eat_at_restaurant`, אנו משתמשים במסלול יחסי. המסלול מתחיל ב-`front_of_house`, שם המודול שמוגדר בעץ המודולים באותה הרמה בה `eat_at_restaurant` מוגדר. המקבילה בעולם מערכת הקבצים במקרה זה תהיה שימוש במסלול `front_of_house/hosting/add_to_waitlist`. התחלת מסלול בשם של מודול משמעה שהמסלול יחסי.

הבחירה האם להשתמש במסלול יחסי או אבסולוטי היא החלטה שתקבלו בהתאם לפרוייקט, והיא תלויה בסבירות האם הגדרתו של פריט זה או אחר תישאר יחד, או בעתיד תופרד, מן הקוד המשתמש בפריט זה. כלך למשל, אם נעביר את המודול `front_of_house` ואת הפונקציה `eat_at_restaurant` לתוך מודול בשם `customer_experience`, נאלץ לעדכן את המסלול האבסולוטי ל- `add_to_waitlist`, אבל המסלול היחסי לא ישתנה. לעומת זאת, במידה ונעביר את הפונקציה `eat_at_restaurant` בנפרד לתוך מודול בשם `dining`, המסלול האבסולוטי לקריאה של `add_to_waitlist` לא ישתנה, בעוד שאת המסלול היחסי יהיה צריך לעדכן. ההעדפה שלנו באופן כללי היא לציין מסלולים אבסולוטיים, מכיוון שסביר יותר שנרצה להעביר הגדרות קוד וקריאות לפריטים באופן בלתי-תלוי זה בזה.

הבה ננסה לקמפל את הקוד מרשימה 7-3 ונגלה מדוע נכשל! השגיאה שנקבל מוצגת ברשימה 7-4.

```console
{{#include ../listings/ch07-managing-growing-projects/listing-07-03/output.txt}}
```

<span class="caption">רשימה 7-4: שגיאות קומפילציה בעקבות בניית הקוד ברשימה 7-3</span>

הודעות השגיאה מתריאות שהמודול `hosting` הוא פרטי. במילים אחרות, אנו משתמשים במסלולים הנכונים עבור המודול `hosting` והפונקציה `add_to_waitlist`, אבל ראסט לא מאפשרת לנו להשתמש בהם בגלל שאין לה גישה לחלקיהם הפרטיים. כברירת מחדל, כל הפריטים בראסט (פונקציות, מתודות, מבחרים, מודולים, וקבועים) הם פרטיים עבורי מודולי-אב. אם תרצו להפוך פריט לפרטי, כגון פונקציה או מבנה, שימו אותו במודול.

פריטים במודול-אב לא יכולים להשתמש בפרטים פרטיים בתוך מודולי-בנים שלהם, אבל פריטים במודולי-בנים יכולים להשתמש בפריטים הנמצאים במודולי-האב שלהם (לכל דורותיהם). זאת משום שמודולי-בנים גוללים ומחביאים את פרטי המימוש שלהם, אבל מודולי-בנים מסוגלים לראות את ההקשר בו הם מוגדרים. כדי להמשיך עם המטפורה, חשבו על חוקי הפרטיות כעל מה שמתרחש בחלק המשרדי של מסעדה: מה שקורה שם הוא פרטי ביחס ללקוחות המסעדה, אבל המנהלים יכולים לראות ולעשות כרצונם במסעדה שתחת אחריותם.

ראסט בוחרת לתפעל את מערכת המודולים כך שהסתרת פרטי מימוש פנימיים היא ברירת המחדל בשפה. כך, קוד חיצוני יודע אילו חלקים של הקוד ניתן לשנות בבטחה, ללא תופעות לוואי. עם זאת, באמצעות שימוש במילת המפתח `pub` , ראסט מאפשרת להפוך לפומביים חלקים פנימיים של קוד במודולי-בנים עבור מודולי-האב.

### חשיפת מסלולים באמצעות מילת המפתח `pub`

הבה נשוב לשגיאה מרשימה 7-4 שציינה לנו שהמודול `hosting` הוא פרטי. אנחנו רוצים שלפונקציה `eat_at_restaurant` ממודול-האב תהיה גישה לפונקציה `add_to_waitlist` במודול-הבן, ולכן נסמן את המודול `hosting` במילת המפתח `pub`, כפי שאנו מראים ברשימה 7-5.

<span class="filename">Filename: src/lib.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-05/src/lib.rs}}
```

<span class="caption">רשימה 7-5: הכרזה על המודול `hosting` כפומבי באמצעות מילת המפתח `pub` בכדי לאפשר שימוש מתוך `eat_at_restaurant`</span>

לרוע המזל, הקוד ברשימה 7-5 עדיין מפיק שגיאה, כפי שרואים ברשימה 7-6.

```console
{{#include ../listings/ch07-managing-growing-projects/listing-07-05/output.txt}}
```

<span class="caption">רשימה 7-6: שגיאות קומפילציה בעקבות בניית הקוד מרשימה 7-5</span>

מה קורה פה? הוספת מילת המפתח `pub` לפני ההכרזה `mod hosting` הופכת את המודול לפומבי. עם שינוי זה, ניתן לגשת ל- `front_of_house`, ולכן אפשר לגשת ל-`hosting`. אבל, _תוכן_ המודול `hosting` עדיין פרטי; הפיכת המודול לפומבי לא הופכת את תוכנו לפומבי. הוספת מילת המפתח `pub` לפני הכרזה על מודול מאפשרת לקוד במודולי-האב שלו להתייחס אליו, אבל לא לגשת לקוד הפנימי שלו. מכיוון שמודולים הם כלי קיבול (containers), לא מתאפשרות פעולות רבות רק מעצם הגדרת המודול כפומבי; עלינו להמשיך ולהגדיר לפחות אחד מהפריטים שבתוך המודול לפומבי גם כן.

השגיאות ברשימה 7-6 מציינות שהפונקציה `add_to_waitlist` היא פרטית. כללי הפרטיות תקפים למבנים, מבחרים, פונקציות, מתודות, ולמודולים.

הבה נהפוך גם את הפונקציה `add_to_waitlist` לפומבית על-ידי הוספת מילת המפתח `pub` לפני ההכרזה על הפונקציה, כמוצג ברשימה 7-7.

<span class="filename">Filename: src/lib.rs</span>

```rust,noplayground,test_harness
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-07/src/lib.rs}}
```

<span class="caption">רשימה 7-7: הוספת מילת המפתח `pub` ל-`mod hosting` ול-`fn add_to_waitlist` מאפשרת לנו לקרוא לפונקציה `eat_at_restaurant`</span>

כעת הקוד יעבור קומפילציה! כדי לראות מדוע הוספת מילת המפתח `pub` מאפשרת לנו להשתמש במסלולים אלה ב-`add_to_waitlist` בהקשר כללי הפרטיות, הבה נתבונן בשני המסלולים: האבסולוטי והיחסי.

במסלול האבסולוטי אנו מתחילים עם `crate`, בסיס עץ המודולים של המכולה שלנו. המודול `front_of_house` מוגדר בבסיס המכולה. בעוד ש-`front_of_house` אינו פומבי, כיוון שהפונקציה `eat_at_restaurant` מוגדרת באותו מודול כמו `front_of_house` ( כלומר ש-`eat_at_restaurant` ו-`front_of_house` הם אחים), ניתן להתייחס ל-`front_of_house` מתוך `eat_at_restaurant`. הבא בתור הוא המודול `hosting`, המסומן עם `pub`. אנו יכולים לגשת אל מודול-האב של `hosting`, ולכן יש לנו גישה ל- `hosting`. לבסוף, הפונקציה `add_to_waitlist` מוגדרת כ-`pub` , ואנו יכולים לגשת אל מודול-האב שלה, ולכן הקריאה לפונקציה מצליחה!

במסלולים יחסיים, הלוגיקה המנחה זהה למקרה של מסלולים אבסולוטיים למעט הצעד הראשון: במקום להתחיל מבסיס המכולה, המסלול מתחיל מ-`front_of_house`. המודול `front_of_house` מוגדר באותו המודל כמו `eat_at_restaurant`, ולכן המסלול היחסי המתחיל במודול בו מוגדר `eat_at_restaurant`, עובד. ואז, בגלל ש-`hosting` ו-`add_to_waitlist` מסומנים כ-`pub`, שאר המסלול עובד, והקריאה לפונקציה תקפה!

כאשר אתם מתכננים לשתף את מכולת הספריה שלכם כך שפרוייקטים אחרים יוכלו להשתמש בקוד, זכרו שה- API הוא החוזה שלכם עם המשתמשים של המכולה שלכם, והוא יקבע כיצד יוכלו להשתמש בה. ישנם שיקולים רבים סביב ביצוע שינויים ב-API הנועדו להקל על משתמשים להסתמך על המכולה שלכם. שיקולים אלה הם מחוץ להישג-ידו של ספר זה; אם אתם מתעניינים בנושא זה, פנו ל-[The Rust API Guidelines][api-guidelines].

> #### התנהלות מיטבית בעבודה עם חבילות הכוללות מכולה בינארית ומכולת ספריה
>
> כבר הזכרנו שחבילה יכולה להכיל גם קובץ _src/main.rs_ כבסיס למכולה בינארית וגם קובץ _src/lib.rs_ כבסיס למכולת ספריה, ושתי המכולות ישאו את שם החבילה כברירת מחדל. חבילות כאלה, הכוללות גם מכולת ספריה וגם מכולה בינארית, יכילו לרוב רק את הקוד המינימלי הדרוש במכולה הבינארית כדי להתחיל את ההרצה שקוראת לקוד ממכולת הספריה. כך מתאפשר לפרוייקטים אחרים להפיק את מירב הפונקציונאליות שהחבילה מאפשרת, זאת משום שהקוד שבמכולת הספריה ניתן לשיתוף.
>
> יש להגדיר את עץ המודולים בקובץ _src/lib.rs_. בדרך זו ניתן להשתמש בכל עצם פומבי במכולה הבינארית באמצעות ציון התחלת מסלול בשם החבילה. המכולה הבינארית הופכת להיות משתמש של ספרית המכולה, בדומה לדרך בה מכולה חיצונית לחלוטין עשויה היתה להשתמש במכולת הספריה: אך ורק תוך שימוש ב-API הפומבי. תכונה זו מסייעת בתכנון ה-API בצורה טובה; אתם, המתכנתים, אינכם רק הכותבים, אלא גם המשתמשים!
>
> [בפרק 12][ch12]<!-- ignore --> נדגים התנהלות ארגונית זו באמצעות תכנית שורת-פקודה שתכלול מכולה בינארית וגם מכולת ספריה.

### מסלולים יחסיים המתחילים עם `super`

ניתן לבנות מסלולים יחסיים המתחילים במודול-האב, במקום במודול הנוכחי או במכולת הבסיס, באמצעות שימוש ב-`super` בתחילת המסלול. נוהל זה שקול, במערכת הקבצים, להתחלת מסלול עם התחביר `..`. שימוש ב-`super` מאפשר לפנות לעצם שאנחנו יודעים שנמצא במודול-האב, וכך יכול להקל על ארגון מחדש של עץ המודולים כאשר המודול מקושר הדוקות למודול-האב, אבל מודול-האב עלול להיות מועבר למקום אחר בעץ המודולים בשלב עתידי כלשהו.

התבוננו בקוד ברשימה 7-8, שממדל מצב בו שף מקבל הזמנה שגויה ומביא אותה בעצמו ללקוח. הפונקציה `fix_incorrect_order`, המוגדרת במודול `back_of_house`, קוראת לפונקציה `deliver_order`, המוגדרת במודול-האב, ע"י ציון המסלול אל `deliver_order` ומתחיל עם `super`:

<span class="filename">Filename: src/lib.rs</span>

```rust,noplayground,test_harness
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-08/src/lib.rs}}
```

<span class="caption">רשימה 7-8: קריאה לפונקציה תוך שימוש במסלול יחסי המתחיל עם `super`</span>

הפונקציה `fix_incorrect_order` נמצאת במודול `back_of_house`, ולכן ניתן להשתמש ב- `super` על מנת לגשת למודול-האב של `back_of_house`, שבמקרה זה הוא `crate`, דהיינו הבסיס. מכאן, אנו מחפשים את `deliver_order`, ומוצאים אותו. מצויין! אנחנו מצפים בסבירות גבוהה שהמודול `back_of_house` והפונקציה `deliver_order` ישארו באותו יחס אחד אל השני, ושבמקרה של ארגון מחדש של עץ המודולים, הם יועברו יחדיו. על כן, השימוש ב- `super` מבטיח שיהיו לנו פחות מקומות בהם יהיה צורך לעדכן את הקוד בעתיד במידה וקוד זה יועבר למודול אחר.

### הפיכת מבנים ומבחרים לפומביים

ניתן גם להשתמש ב-`pub` כדי לסמן מבנים ומבחרים כפומביים, אבל ישנם כמה דגשים בנוגע לשימוש ב-`pub` עם מבנים ומבחרים. שימוש ב-`pub` לפני הגדרה של מבנה הופך את המבנה לפומבי, אבל שדות המבנה נותרים פרטיים. לגבי כל שדה ושדה ניתן לקבוע אם ישאר פרטי או יהפוך לפומבי. ברשימה 7-9 הגדרנו את המבנה `back_of_house::Breakfast` כפומבי, וכמכיל שדה פומבי בשם `toast` ושדה פרטי בשם `seasonal_fruit`. מצב זה ממדל את המקרה בו במסעדה הלקוח יכול לבחור את סוג הלחם שמגיע עם הארוחה, אבל השף מחליט איזה פירות מלווים את הארוחה, וזאת בהתבסס על זמינות הפירות לפי העונה והמלאי. הפירות הזמינים משתנים במהירות, ולכן הלקוחות לא יכולים לבחור את הפירות, או אפילו לראות איזה פירות הם יקבלו.

<span class="filename">Filename: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-09/src/lib.rs}}
```

<span class="caption">רשימה 7-9: מבנה עם שדות פרטיים ושדות פומביים</span>

בגלל שהשדה `toast` במבנה `back_of_house::Breakfast` הוא פומבי, אנחנו יכולים לכתוב ולקרוא לשדה `toast` שבמבנה `eat_at_restaurant` באמצעות תחביר הנקודה. שימו לב שלא ניתן להשתמש בשדה `seasonal_fruit` שבמבנה `eat_at_restaurant` בגלל ש-`seasonal_fruit` הוא פרטי. נסו להסיר את סימון ההערה בשורה שמשנה את ערך השדה `seasonal_fruit` וראו איזו הודעת שגיאה תקבלו!

בנוסף, שימו לב שמכיוון שב-`back_of_house::Breakfast` מופיע שדה פרטי, המבנה צריך לספק פונקציה משוייכת פומבית שבונה מופע של `Breakfast` (במקרה שלנו קראנו לפונקציה כזו `summer`). לו `Breakfast` לא היתה מספקת פונקציה כזו, לא היינו יכולים ליצור מופע של `Breakfast` ב-`eat_at_restaurant` משום שלא ניתן לבצע השמה של ערך לשדה הפרטי `seasonal_fruit` אשר ב-`eat_at_restaurant`.

בניגוד לכך, אם מכריזים על מבחר כפומבי, כל הווריאנטים שלו הופכים פומביים גם הם. צריך למקם את `pub` רק לפני מילת המפתח `enum`, כפי שרואים ברשימה 7-10.

<span class="filename">Filename: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-10/src/lib.rs}}
```

<span class="caption">רשימה 7-10: ציון מבחר כפומבי הופך לפומביים את כל הווריאנטים שלו</span>

בגלל שהפכנו את המבחר `Appetizer` לפומבי, ניתן להשתמש בווריאנטים `Soup` ו-`Salad` ב-`eat_at_restaurant`.

מבחרים אינם יעילים במיוחד אם הווריאנטים שלהם אינם פומביים; זה יהיה מציק אם נצטרך לבאר את כל הווריאנטים של המבחר ב-`pub`, ולכן ברירת המחדל היא לחסוך מאיתנו עבודה מיותרת זו. לעומת זאת, מבנים הם שימושיים גם כאשר השדות שלהם לא פומביים, ולכן עבור שדות של מבנים חל החוק הקפדני לפיו הכל פרטי כברירת מחדל, אלא אם מבואר אחרת באמצעות `pub`.

ישנו עוד מצב אחד המערב את `pub` שעליו עוד לא דיברנו, וזה מביא אותנו לתכונה האחרונה של מערכת המודולים: מילת המפתח `use`. תחילה נעבור על `use` בפני עצמו, ואז נראה כיצד לשלב בין `pub` ל-`use`.

[pub]: ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exposing-paths-with-the-pub-keyword
[api-guidelines]: https://rust-lang.github.io/api-guidelines/
[ch12]: ch12-00-an-io-project.html
