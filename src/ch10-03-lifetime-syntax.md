## וידוא הפניות באמצעות משך-חיים

משך-חיים הוא סוג נוסף של ג'נריק בו כבר עשינו שימוש. במקום להבטיח שלטיפוס יש את ההתנהגות שאנו רוצים, משך-חיים מבטיח תקפות הפניות למשך הזמן בו הן נחוצות.

פרט בו לא דנו בסעיף ["הפניות והשאלות"]()<!-- ignore --> בפרק 4 הוא העובדה שלכל הפניה בראסט יש *משך-חיים* (lifetime), שהוא המתחם בו ההפניה תקפה. רוב הזמן, משך-החיים של הפניות אינו מפורש והקומפיילר יכול להסיק אותו, בדיוק כמו שרוב הזמן הקומפיילר מסיק טיפוסים של משתנים. יש חובה לבאר טיפוסים כאשר יש כמה טיפוסים אפשריים ולכן הקומפיילר לא יכול להסיק לבדו את הטיפוס. באופן דומה, יש חובה לבאר את משך החיים של הפניה כאשר משך החיים יכול להיות מקושר בכמה דרכים, והקומפיילר לא יכול להסיק חד-משמעית את משך החיים. ראסט דורשת מאיתנו לבאר את היחסים באמצעות פרמטרי משך-חיים גנריים על מנת להבטיח שההפניות שיהיו בשימוש בזמן הריצה יהיו תקפות בוודאות.

ברוב שפות התכנות, המושג של ביאור משך-חיים אינו קיים, ולכן סביר שהדיון כאן ירגיש מעט זר. למרות שבפרק זה לא נכסה את כל פרטי המושג משך-חיים, נדון בדרכים נפוצות שעשויות להוביל אתכם לתחביר של משך-חיים כך שתוחלו להתרגל למושג.

### מניעת הפניות משתלשלות באמצעות ביאור משך-חיים

השימוש העיקרי של ביאור משך-חיים הוא כדי למנוע *הפניות משתלשלות*, שגורמות לתכנית להפנות לדאטה שאינו דאטה שאמורים להפנות אליו. התבוננו ברשימה 10-16, בה יש מתחם חיצונים ומתחם פנימי.

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-16/src/main.rs}}
```


<span class="caption">רשימה 10-16: ניסיון להשתמש בהפניה שערכה יצא מהמתחם</span>

> שימו לב: הדוגמאות ברשימות 10-16, 10-17, ו-10-23 מכריזות על משתנים מבלי לספק עבורם ערך תחילי, כך ששם המשתנה מופיע במתחם החיצוני. במבט ראשון, נראה שזה עומד בסתירה עם העובדה שבראסט אין ערכי null. אולם, אם ננסה להשתמש במשתנה לפני שנתנו לו ערך, נקבל שגיאת קומפילציה, זאת-אומרת שראסט אכן לא מאפשרת ערכי null.

המתחם החיצוני מכריז על משתנה בשם `r` ללא ערך תחילי, והמתחם הפנימי מכריז על משתנה בשם `x` עם הערך התחילי 5. בתוך המתחם הפנימי, אנו מנסים לגרום לכך ש- `r` יהיה הפניה ל- `x`. אחר-כך, המתחם הפנימי מסתיים, ואנו מנסים להדפיס את הערך ב-`r`. קוד זה לא עובר קומפילציה כיוון שהערך אליו `r` מפנה יצא מחוץ למתחם לפני הניסיון להשתמש בו. הינה הודעת השגיאה:

```console
{{#include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-16/output.txt}}
```

המשתנה `x` אינו "שורד מספיק זמן" הסיבה היא ש-`x` יהיה מחוץ למתחם כאשר המתחם הפנימי מסתיים בשורה 7. אבל `r` עדיין תקף במתחם החיצוני; כיוון שהמתחם שלו מסתיים מאוחר יותר, אנו אומרים שהוא "שורד יותר זמן". לו ראסט היתה מאפשרת לקוד לעבוד, `r` היה מפנה למקום בזיכרון שאיבד את תוקפו כאשר `x` יצא מן המתחם, וכל דבר שהיינו מנסים לעשות עם `r` היה מסוכן, או לכל הפחות חסר משמעות. אם כן, כיצד קובעת ראסט שהקוד הזה אינו תקין? היא משתמשת בבודק ההשאלות.

### בודק ההשאלות

לקומפיילר של ראסט יש *בודק השאלות* (borrow checker) שמשווה בין מתחמים כדי לקבוע את תקפות כל ההפניות. רשימה 10-17 מציגה את אותו הקוד כמו ברשימה 10-16, בתוספת ביאורים שמראים את משך-החיים של המשתנים.

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-17/src/main.rs}}
```


<span class="caption">רשימה 10-17: ביאורים של משך-החיים של `r` ושל `x`, להם קוראים `'a` ו- `'b`, בהתאמה</span>

כאן, ביארנו את משך-החיים של `r` עם `'a` ואת משך-החיים של `x` עם `'b`. כפי שאתם רואים, בלוק ה-`'b` הפנימי קטן יותר מבלוק ה-`'a` החיצוני. בזמן הקומפילציה, ראסט משווה בין משך-החיים של שני המשתנים ורואה שמשך-החיים של `r` הוא `'a` ושהוא מפנה לזיכרון שמשך החיים שלו הוא `'b`. ראסט אינה מקבלת את התכנית משום ש-`'b` קצר יותר מ-`'a`: ההפניה שורדת מעבר לזמן השרידות של מושא ההפניה.

רשימה 10-18 מתקנת את הקוד כך שלא יהיה בו משתנה משתלשל, והוא עובר קומפילציה ללא שגיאות.

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-18/src/main.rs}}
```


<span class="caption">רשימה 10-18: הפניה תקפה משום שלדאטה יש משך חיים ארוך יותר ממשך החיים של ההפניה</span>

כאן, משך החיים של `x` הוא `'b`, שבקרה זה אורך יותר ממשך החיים `'a`. זאת אומר ש-`r` יכול להפנות ל-`x` כיוון שראסט יודעת שההפניה ב-`r` תקפה כל עוד `x` עצמו תקף.

עכשיו משאתם יודעים היכן נמצא משך-החיים של הפניות וכיצד ראסט מנתחת משכי-חיים על מנת להבטיח שהפניות תמיד יהיו תקפות, הבה נתבונן במשך-חיים גנרי עבור פרמטרים ועבור ערכים חוזרים בהקשר של פונקציות.

### משך-חיים גנרי בפונקציות

הבה נכתוב פונקציה שמחזירה את הארוכה מבין שתי מחרוזות. פונקציה זו מקבלת שני חיתוכי מחרוזת ומחזירה חיתוך מחרוזת יחיד. לאחר המימוש של הפונקציה `longest`, הקוד ברשימה 10-19 אמור להדפיס `The longest string is abcd`.

<span class="filename">Filename: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-19/src/main.rs}}
```


<span class="caption">רשימה 10-19: פונקצית `main` אשר קוראת לפונקציה `longest` כל מנת למצוא את המחרוזת הארוכה מבין שני חיתוך מחרוזת</span>

שימו לב שאנחנו רוצים שהפונקציה תקבל חיתוכי מחרוזת, שהם הפניות, ולא מחרוזות, כיוון שאנחנו לא רוצים שהפונקציה `longest` תיקח בעלות על הפרמטרים שלה. פנו, אם צריך, לסעיף ["חיתוכי מחרוזת כפרמטרים"]()<!-- ignore --> בפרק 4 לדיון נוסף אודות השימוש בפרמטרים כמו שמופיעים ברשימה 10-19.

ניסיון לממש את הפונקציה `longest` כפי שמוצג ברשימה 10-20, לא יעבור קומפילציה.

<span class="filename">Filename: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-20/src/main.rs:here}}
```


<span class="caption">רשימה 10-20: מימוש של הפונקציה `longest` שמחזיר את המחרוזת הארוכה מבין שני חיתוכי מחרוזת, אבל עדיין לא עובר קומפילציה</span>

אנו מקבלים את הודעת השגיאה הבאה, אודות משך-החיים של כמה מהמשתנים:

```console
{{#include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-20/output.txt}}
```

הטקסט המלווה את הודעת השגיאה מבהיר שהטיפוס המוחזר זקוק לפרמטר משך-חיים גנרי מכיוון שראסט אינה יכולה להסיק האם ההפניה שתוחזר תהיה הפניה ל-`x` או ל-`y`. למעשה, גם אנחנו לא יודעים זאת, כי בלוק ה-`if` של הפונקציה מחזיר הפניה ל-`x` בעוד בלוק ה- `else` מחזיר הפניה ל-`y`!

כאשר אנו מגדירים פונקציה זו, אנחנו לא יודעים מה יהיו הערכים הקונקרטיים שיועברו לפונקציה, ולכן אנחנו לא יודעים איזה בלוק קוד, זה של ה-`if` או זה של ה-`else` יבוצע. אנחנו גם לא יודעים מהם משכי-החיים של ההפניות שיועברו, ולכן לא ניתן להסתכל על המתחמים המתאימים, כמו שעשינו ברשימה 10-17 וברשימה 10-18, על מנת לקבוע האם ההפניה שנחזיר תמיד תהיה תקפה. גם בודק-ההשאלות לא יכול לקבוע זאת, כיוון שהוא לא יודע איך משכי-החיים של `x` ושל `y` מתייחסים לערך המוחזר. על מנת לתקן מצב זה, נוסיף פרמטר משך-חיים גנרי שמגדיר את היחס בין ההפניות כדי שבודק ההשאלות יוכל לבצע את הבדיקות שלו.

### תחביר ביאור משך-חיים

ביאורי משך-חיים אינן משנות את משך החיים של ההפניות. הן מתארות את היחסים בין משכי-החיים של כמה הפניות, ללא השפעה על משכי-חיים אלה. בדיוק כמו שפונקציה יכולה לקבל כל טיפוס שהוא כאשר החותם שלה מציין פרמטר טיפוס גנרי, כך גם יכולה פונקציה לקבל הפניה עם כל משך-חיים שהוא על-ידי ציון פרמטר משך-חיים גנרי.

לביאורי משך-חיים יש תחביר קצת יוצא-דופן: שמות של פרמטרי משך-חיים חייבים להתחיל עם גרש (`'`), ובדרך-כלל הם כתובים באותיות קטנות ובעלי שמות קצרים מאוד, בדומה לטיפוסים גנריים. רוב המתכנתים משתמשים ב-`'a` עבור ביאור משך-החיים הראשון. אנו ממקמים ביאורי פרמטרים של משך-חיים לאחר הסימן `&` של הפניה, תוך שימוש ברווח כדי להפריד את הביאור מטיפוס ההפניה.

הנה כמה דוגמאות: הפניה ל-`i32` ללא פרמטר משך-חיים, הפניה ל-`i32` עם פרמטר משך-חיים בשם `'a`, והפניה ברת-שינוי ל-`i32` שגם לה פרמטר משך-חיים בשם `'a`.

```rust,ignore
&i32        // a reference
&'a i32     // a reference with an explicit lifetime
&'a mut i32 // a mutable reference with an explicit lifetime
```

לביאור משך-חיים בודד, בפני עצמו, אין משמעות רבה, כיוון שמטרת הביאורים היא לאמר לראסט כיצד פרמטרי משך-חיים גנריים של כמה הפניות מתחייסים זה לזה. הבה נבחן איך משכי-החיים מתייחסים זה לזה בהקשר של הפונקציה `longest`.

### ביאור משך-חיים בחותמי פונקציות

על מנת להשתמש בביאורי משך-חיים בחותמי פונקציות, יש להכריז על פרמטר משך-החיים הגנרי בתוך סוגרים משולשים בין שם הפונקציה לרשימת הפרמטרים שלה, בדיוק כפי שעושים עם פרמטרי טיפוסים גנריים.

אנחנו רוצים שהחותם יבטא את המגבלה הבאה: ההפניה המוחזרת צריכה להיות תקפה כל עוד שני הפרמטרים תקפים. זהו היחס בין משכי-החיים של הפרמטרים והערך המוחזר. לפרמטר משך-החיים נקרא `'a` ונוסיף אותו לכל הפניה, כפי שמוצג ברשימה 10-21.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-21/src/main.rs:here}}
```


<span class="caption">רשימה 10-21: הגדרת הפונקציה `longest` וציון שלכל ההפניות בחותם יש את אותו משך-החיים `'a`</span>

קוד זה אמור לעבור קומפילציה ולהפיק את התוצאה המבוקשת כאשר נשתמש בו עם הפונקציה `main` מרשימה 10-19.

חותם הפונקציה אומר לראסט שקיים משך-חיים `'a`, שביחס אליו הפונקציה מקבלת שני משתנים, ושכל אחד מהם הוא חיתוך מחרוזת ששורד לפחות במשך `'a`. חותם הפונקציה גם אומר לראסט שחיתוך המחרוזת שמוחזר מהפונקציה ישרוד גם הוא לפחות במשך `'a`. למעשה, משמעות הדבר היא שמשך החיים של הערך המוחזר על-ידי הפונקציה `longest` הוא הקצר מבין משך החיים של הארגומנט הראשון לפונקציה ומשך החיים של הארגומנט השני. יחסים אלה הם מה שאנחנו רוצים שראסט תאכוף כאשר היא מנתחת את הקוד.

זכרו, כאשר אנו מציינים פרמטרי משך-חיים בחותם של פונקציה, אין אנו משנים את משך החיים של אף ערך המועבר לפונקציה. כל שאנו עושים הוא לציין שבודק ההשאלות צריך לדחות ערכים שמשכי החיים שלהם לא מקיימים את היחסים שפרמטרי משך-החיים מקיימים. שימו לב שהפונקציה `longest` לא צריכה לדעת בדיוק כמה זמן `x` ו-`y` ישרדו, אלא רק שקיים מתחם כל שהוא שניתן להחליף עבור `'a` שמקיים את תנאי החותם.

כאשר מבארים משכי-חיים בפונקציה, הביאורים נכתבים בחותם הפונקציה, ולא בגוף הפונקציה. ביאורי משכי-החיים הופכים לחלק מהחוזה של הפונקציה, בדומה לתפקיד של טיפוסים בחותם. כאשר חותמי הפונקציות כוללים תנאי משך-חיים, מלאכת הניתוח שהקומפיילר של ראסט צריך לעשות נהיית פשוטה יותר. במידה ויש בעיה עם דרך ביאור הפונקציה או בדרך בה קוראים לה, שגיאות הקומפיילר יכולות להצביע אל החלק בקוד, ואל המגבלות, ביתר דיוק. אם, לחילופין, הקומפיילר של ראסט היה עושה יותר הסקות בעצמו אודות מה שאנחנו התכוונו שהיחסים בין משכי-החיים אמורים להיות, הקומפיילר יכול להתקשות יותר לספק הודעות מועילות ולמקם את הבעיה בצורה פחות מדוייקת.

כאשר מעבירים הפניות קונקרטיות ל- `longest`, משך החיים הקונקרטי שמחליף את `'a` הוא החלק של המתחם של `x` שחופף עם המתחם של `y`. במילים אחרות, משך-החיים הגנרי `'a` יקבל את משך החיים הקונקרטי ששווה לקטן מבין משך החיים של `x` ומשך החיים של `y`. כיוון שביארנו את הערך המוחזר כבעל או`'a`, ההפניה המוחזרת תהיה תקפה גם במשך התקופה הקצרה מבין משכי-החיים של `x` ושל `y`.

הבה נתבונן כיצד ביאורי משך-החיים מגבילים את השימוש בפונקציה `longest` על-ידי כך שנעביר לה הפניות בעלות משכי-חיים קונקרטיים שונים. רשימה 10-22 הינה דוגמא די ברורה מעליה.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-22/src/main.rs:here}}
```


<span class="caption">רשימה 10-22: שימוש בפונקציה `longest` עם הפניות לערכי `String` בעלות משכי-חיים קונקרטיים שונים</span>

בדוגמא זו, `string1` תקף עד סוף המתחם החיצוני, `string2` תקף עד סוף המתחם הפנימי, ו-`result` מפנה למשהו שתקף עד סוף המתחם הפנימי. הריצו קוד זה, ותיווכחו שבודק ההשאלות מאשר אותו; הקוד יעבור קומפילציה וידפיס `The longest string
is long string is long`.

כעת, הבה ננסה דוגמא שמראה שמשך החיים של `result` חייב להיות הקצר מבין משכי-החיים של הארגומנטים. נעביר את ההכרזה על המשתנה `result` אל מחוץ למתחם אבל נשאיר את ההשמה של הערך למשתנה `result` בתוך המתחם עם `string2`. ואז נעביר את הקריאה ל- `println!` שמשתמשת ב-`result` אל מחוץ למתחם הפנימי, לאחר שהמתחם הפנימי מסתיים. הקוד ברשימה 10-23 לא יעבור קומפילציה.

<span class="filename">Filename: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-23/src/main.rs:here}}
```


<span class="caption">רשימה 10-23: ניסיון להשתמש ב- `result` לאחר ש-`string2` יצא מהמתחם</span>

כאשר מנסים לקמפל את הקוד מקבלים את השגיאה הבאה:

```console
{{#include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-23/output.txt}}
```

שגיאה זו מראה שבשביל ש- `result` יהיה תקף לשימוש בפקודת ה-`println!`, על `string2` להיות תקף עד לסוף המתחם החיצוני. ראסט יודעת זאת משום שביארנו את משכי-החיים של הפרמטרים של הפונקציה ושל הערך המוחרזר באמצאות אותו פרמטר משך-החיים `'a`.

אנו, כבני-אדם, מסוגלים להתבונן בקוד ולראות ש-`string1` ארוכה יותר מ-`string2` ולכן `result` יכיל הפניה של `string1`. בגלל ש-`string1` עוד לא יצא אל מחוץ למתחם, הפניה ל-`string1` עדיין תהיה תקפה בקריאה ל-`println!`. אבל, הקומפיילר לא יכול לראות שההפניה תקפה במקרה זה. אמרנו לראסט שמשך החיים של ההפניה המוחזרת על-ידי הפונקציה `longest` הוא הקצר מבין משכי-החיים של ההפניות שהועברו לפונקציה. לכן, בודק ההשאלות לא מקבל את הקוד מרשימה 10-23 שכן לא ניתן לשלול הפניה לא תקפה.

נסו לתכנן ניסויים נוספים תוך התאמת הערכים ומשכי-החיים של ההפניות המועברות לפונקציה `longest`, והדרך בה משתמשים בהפניה המוחזרת. נסו לנתח את המצב בעצמכם ושארו, לפני הקימפול, האם הקוד יקבל את אישור בודק ההשאלות, או לא; ואז בדקו האם צדקתם!

### חשיבה במונחי משך-חיים

הדרך בה יש לציין את משך-החיים של פרמטרים תלויה במה שהקוד אמור לבצע. למשל, לו היינו משנים את המימוש של הפונקציה `longest` כך שתמיד תחזיר את הפרמטר הראשון במקום את חיתוך המחרוזת הארוכה ביותר, לא היה צורך לציין משך-חיים עבור הפרמטר `y`. הקוד הבא עובר קומפילציה:

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-08-only-one-reference-with-lifetime/src/main.rs:here}}
```

ציינו את פרמטר משך-החיים `'a` כפרמטר של `x` ושל הערך המוחזר, אבל לא של הפרמטר `y`, משום שמשך החיים של `y` כלל לא קשור למשך החיים של `x` או של הערך המוחזר.

כאשר מחזירים הפניה מפונקציה, פרמטר משך-החיים עבור הטיפוס המוחזר חייב להתאים למשך החיים של אחד הפרמטרים של שהועברו לפונקציה. אם ההפניה המוחזרת *אינה* מתייחסת לאף אחד מהפרמטרים, משמע שהיא חייבת להפנות לערך שנוצר בתוך הפונקציה. אולם, ערך שכזה בהכרח יהיה הפניה משתלשלת כיוון שהערך יצא מהמתחם בסוף הפונקציה. התבוננו בניסיון הבא, שלא יעבור קומפילציה, למימוש של הפונקציה `longest`:

<span class="filename">Filename: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-09-unrelated-lifetime/src/main.rs:here}}
```

כאן, למרות שציינו את פרמטר משך-החיים `'a` עבור הטיפוס המוחזר, מימוש זה לא יעבור קומפילציה בגלל שמשך-החיים של הערך המוחזר אינו קשור למשך-החיים של אף אחד מהפרמטרים של הפונקציה. הינה הודעת השגיאה שנקבל:

```console
{{#include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-09-unrelated-lifetime/output.txt}}
```

הבעיה היא שהמשתנה `result` יוצא מהמתחם והזיכרון שלו מנוקא בסוף גוף הפונקציה `longest`. אנחנו גם מנסים להחזיר מהפונקציה הפניה ל-`result`. אין דרך לציין פרמטרי משך-חיים שלא יצרו הפניה משתלשלת זו, וראסט אינה מאפשרת יצירת הפניות משתלשלות. במקרה זה, הפתרון הטוב ביותר יהיה להחזיר משתנה שהערך שלו בבעלותו במקום הפניה, וכך הפונקציה הקוראת היא זאת שאחראית לניקיון הזיכרון של הערך.

בסופו של דבר, המטרה של תחביר משך-חיים היא לקשר את משכי-החיים של כמה פרמטרים וערכים מוחזרים של פונקציות. ברגע שהקשרים התחביריים נוצרו, ראסט משתמשת במידע זה כדי לאפשר פעולות בעלות בטיחות זיכרון ואינה מאפשרת פעולות שיוצרות מצביעים משתלשלים, או כאלה שמפרות בכל דרך שהיא את ערובות הביטחון של ראסט לגבי ניהול זיכרון.

### ביאורי משך-חיים בהגדרות מבנים

עד כה, המבנים שהגדרנו אכסנו ערכים בבעלות עצמית. ניתן להגדיר מבנים שמכילים הפניות, אבל במקרה שכזה יש צורך להוסיף ביאורי משך-חיים עבור ההפניות שבהגדרת המבנה. ברשימה 10-24 יש מבנה בשם `ImportantExcerpt` שמכיל חיתוך מחרוזת.

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-24/src/main.rs}}
```


<span class="caption">רשימה 10-24: למבנה שמכיל הפניה נדרש ביאור משך-חיים</span>

למבנה זה יש שדה יחיד בשם `part` שמאחסן חיתוך מחרוזת, דהיינו הפניה. כמו עם טיפוסי גנריים, אנו מכריזים על השם של פרמטר משך החיים בתוך סוגריים משולשים לאחר השם של המבנה כדי בנוכל להשתמש בפרמטר משך החיים בגוף ההגדרה של המבנה. משמעות ביאור זה היא שמופע של `ImportantExcerpt` לא יכול לשרוד מעבר למשך החיים של ההפנה שהוא מאחסן בשדה `part` שלו.

כאן, הפונקציה `main` יוצרת מופע של המבנה `ImportantExcerpt` שמאחסן הפניה למשפט הראשון של ה- `String` שבבעלות המשתנה `novel`. הדאטה ב-`novel` קיים לפני יצירת המופע של `ImportantExcerpt`. בנוסף, `novel` אינו יוצא מן המתחם עד אחרי שהמופע של `ImportantExcerpt` יוצר מהמתחם, ולכן ההפניה במופע תקפה.

### השמטת משך-חיים

למדתם שלכל הפניה יש משך-חיים ושצריך לציין פרמטרי משך-חיים עבור פונקציות או מבנים שמשתמשים בהפניות. אולם, בפרק 4 ראינו פונקציה ברשימה 4-9, שמוצגת שוב ברשימה 10-25, שעברה קומפילציה ללא ביאור משך-חיים.

<span class="filename">Filename: src/lib.rs</span>

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-25/src/main.rs:here}}
```


<span class="caption">רשימה 10-25: פונקציה, שהוגדרה ברשימה 4-9, שעוברת קומפילציה ללא ביאור משך-חיים, למרות שהפרמטר והערך המוחזר שלה הם הפניות</span>

הסיבה שניתן לקמפל פונקציה זו ללא צורך בביאור משך-חיים היא הסטורית: בגרסאות קודמות ל-1.0 של ראסט, קוד זה לא היה עובר קומפילציה מכיוון שכל הפניה היתה צריכה משך-חיים מפורש. בזמנו, חותם הפונקציה היה נכתב כך:

```rust,ignore
fn first_word<'a>(s: &'a str) -> &'a str {
```

לאחר התנסות עם כתיבה ראסט בגרסתה זו, צוות ראסט מצא שמתכנתי ראסט הקלידו ביאורי משך-חיים, בצורה רפטטיבית, שוב ושוב. מצבים אלו היו צפויים מראש והופיעו בתבניות דטרמיניסטיות. צוות הפיתוח קודד תבניות אלה ישירות לקומפיילר כדי שבודק ההשאלות יוכל להסיק את משכי-החיים במצבים אלה ולא ידרוש ביאור מפורש.

פיסת הסטוריה זו בהתפתחות ראסט רלוונטית כיוון שיתכן שתבניות נוספות יוספו לקומפיילר. יתכן שבעתיד עוד פחות ביאורי משך-חיים יהיו נחוצים.

התבנייות שבנויות לתוך הניתוח שראסט מבצעת על הפניות נקראות *כללי השמטת משך-חיים*. כללים אלה אינם כללי שמתכנתים צריכים לציית להם; הכללים האלה הם אוסף של מקרים ספציפיים שהקומפיילר מזהה, ואם הקוד שלכם מתאים למקרים אלה, אז אין צורך לציין משך-חיים באופן מפורש.

כללי ההשמטה לא מספקים ממשק מלא. ראסט מיישמת את הכללים באופן דטרמינסטי, ואם נותר עוד ספק באשר למשך החיים של הפניה זו או אחרת, הקומפיילר לא ינסה לנחש משך-חיים שכזה. במקום זאת, הקומפיילר יספק הודעת שגיאה שאותה תצטרכו לפתור על-ידי הוספת ביאורי משך-חיים.

משך-חיים של פרמטר של פונקציה או מתודה נקרא *משך-חיים של קלט*, ומשך-חיים של ערך מוחזר נקרא *משך-חיים של פלט*.

הקומפיילר משתמש בשלושה כללים כדי לבצע הסקות אודות משך-חיים של הפניות במקרה בו לי ניתנים ביאורים מפורשים. הכלל הראשון מיושם עבור משך-חיים של קלט, והכללים השני והשלישי מייושמים עבור משך-חיים של פלט. אם הקומפיילר ממצא את שלושת הכללים האלה ועדיין ישנה הפנייה שמשך-החיים שלה לא נקבע, הקומפיילר יעצור עם הודעת שגיאה. הכללים האלה תקפים עבור הגדרות `fn` ועבור בלוקי `impl`.

הכלל הראשון הוא שהקומפיילר מייחס פרמטר משך-חיים לכל פרמטר שהוא הפניה. במילים אחרות, פונקציה עם פרמטר אחד מקבלת פרמטר משך-חיים אחד: `fn foo<'a>(x: &'a i32)`; פונקציה עם שני פרמטרים מקבלת שני פרמטרי משך-חיים: `fn foo<'a, 'b>(x: &'a i32,
y: &'b i32)`; וכן הלאה.

הכלל השני הוא שאם יש בדיוק פרמטר אחד של משך-חיים של קלט, משך-חיים זה הוא גם משך החיים של כל פרמטרי משך-החיים של פלט: `fn foo<'a>(x: &'a i32)
-> &'a i32`.

הכלל השלישי הוא שאם יש כמה פרמטרי משך-חיים של קלט, אבל אחד מהם הוא `&self` או `&mut self` משום שמדובר במתודה, אז משך החיים של `self` הוא גם משך החיים של כל פרמטרי ערך החיים של פלט. הכלל השלישי מקל על כתיבת וקריאת מתודות, שכן הוא מאפשר הפחתה בכמות הסימנים הנדרשים לכתיבה.

הבה נעמיד פנים שאנחנו הקומפיילר. ניישם כללים אלה כדי להסיק את משך החיים של כל הפניה בחותם של הפונקציה `first_word` ברשימה 10-25. תחילה, בחותם אין כלל משך-חיים שמקושר עם ההפניות:

```rust,ignore
fn first_word(s: &str) -> &str {
```

הקומפיילר מיישם את הכלל הראשון, לפיו כל פרמט מקבל משך-חיים משלו. נקרא לו `'a`, כרגיל, ולכן כעת החותם נראה כך:

```rust,ignore
fn first_word<'a>(s: &'a str) -> &str {
```

הכלל השני ניתן ליישום כאן כיוון שיש בדיוק משך-חיים אחד. לפי הכלל השני, משך-החיים של פרמטר הקלט משוייך למשך החיים של הפלט, ולכן החותם נראה כך:

```rust,ignore
fn first_word<'a>(s: &'a str) -> &'a str {
```

עכשיו כל ההפניות בחותם הפונקציה מתוייגות עם פרמטרי משך-חיים, והקומפיילר יכול להמשיך במלאכת ניתוח הקוד מבלי שצריך לספק ביאורי משך-חיים נוספים בחותם הפונקציה.

הבה נתבונן בדוגמא נוספת, הפעם תוך שימוש בפונקציה `longest` שהתחילה את דרכה ברשימה 10-20 ללא פרמטרי משך-חיים:

```rust,ignore
fn longest(x: &str, y: &str) -> &str {
```

הבה ניישם את הכלל הראשון: כל פרמטר מקבל משך-חיים משלו. הפעם יש לנו שני פרמטרים במקום אחד, ולכן גם שני פרמטרי משך-חיים:

```rust,ignore
fn longest<'a, 'b>(x: &'a str, y: &'b str) -> &str {
```

ניתן לראות שהכלל השני אינו יישים כאן כי יש יותר מפרמטר אחד של משך-חיים של קלט. הכלל השלישי אינו יישים אף הוא, כיוון ש-`longest` היא פונקציה ולא מתודה, ולכן אף אחד מהפרמטרים אינו `self`. לאחר מעבר על שלושת הכללים, אנחנו עדיין לא יודעים מהו משך-החיים של הטיפוס המוחזר. זו הסיבה להודעת השגיאה שקיבלנו כשניסינו לקמפל את הקוד ברשימה 10-20: הקומפיילר יישם את כללי השמטת משך-החיים אבל לא הצליח לדעת מהו משך החיים של כל אחת מההפניות בחותם.

בכלל שהכלל השלישי ניתן ליישום רק עבור חותמי מתודות, נעבור כעת להתבונן במשכי-חיים בהקשר זה על מנת לראות מדוע הכלל השלישי מאפשר לנו להימנע, לעיתים קרובות, מביאורי משך-חיים בחותמי מתודות.

### ביאורי משך-חיים בהגדרת מתודות

כאשר אנו מממשים מתודות עבור מבנים עם משכי-חיים, אנו משתמשים בתחביר דומה לתחביר של פרמטרי טיפוסים גנריים שמוצג ברשימה 10-11. איפה מכריזים והיכן ומשתמשים בפרמטרי משך-חיים תלוי בהאם הם מקושרים לשדות המבנה או לפרמטרי המתודה והערכים המוחזרים.

שמות משכי חיים עבור שדות של מבנה תמיד חייבים להיות מוכרזים מייד לאחר מילת המפתח `impl` ואז משתמשים בהם לאחר שם המבנה, כיוון שמשכי-חיים אלה הם חלק מהטיפוס של המבנה.

בחותמים של מתודות בתוך בלוק ה-`impl`, הפניות יכולות להיות קשורות למשך החיים של הפניות בשדות המבנה, או שהן בלתי תלויות. בנוסף, כללי השמטת משך-חיים בדרך-כלל גורמות לכך שביאורי משך-חיים אינם נחוצים בחותמים של מתודות. הבה נתבונן בכמה דוגמאות המשתמשות במבנה `ImportantExcerpt` אותו הגדרנו ברשימה 10-24.

ראשית, נשתמש במתודה בשם `level` שלה פרמטר אחד והוא הפניה ל-`self` והערך המוחזר שלה הוא `i32`, שהוא אינו הפניה:

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-10-lifetimes-on-methods/src/main.rs:1st}}
```

ההכרזה על פרמטר משך-החיים אחרי ה-`impl` והשימוש בפרמטר אחרי שם הטיפוס הם הכרחיים, אבל אין חובה לבאר את משך-החיים של ההפניה ל-`self` הודות לכלל הראשון של השמטת משך-חיים.

הינה דוגמא בה הכלל השלישי של השמטת משך-חיים ניתן ליישום:

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-10-lifetimes-on-methods/src/main.rs:3rd}}
```

יש כאן שני משכי-חיים של קלט, ולכן ראסט מפעילה את הכלל הראשון של השמטת משך-חיים ונותנת ל-`&self` ול-`announcement` משך-חיים משלהם. אז, כיוון שאחד הפרמטרים הוא `&self`, הערך המוחזר מקבל את משך-החיים של `&self`, וכך משך החיים של כל אחת מההפניות ידוע.

### משך החיים הסטטי

משך-חיים מיוחד בו אנו צריכים עוד לדון הוא משך החיים `'static`, שמציין שההפניה שהוא מתייג יכולה לשרוד לכל אורך החיים של התכנית כולה. לכל מחרוזת מפורשת יש את משך החיים `'static`, עובדה שניתן לבאר כך:

```rust
let s: &'static str = "I have a static lifetime.";
```

הטקסט של מחרוזת זו מאוחסן ישירות בבינרי של התכנית, שהוא תמיד נגיש. לכן, משך החיים של כל מחרוזת מפורשת הוא `'static`.

יתכן ותראו הצעות מהקומפיילר להשתמש במשך החיים `'static`,. אבל לפני שמציינים `'static` כמשך החיים של הפניה, חשבו האם ההפניה שלכם באמת שורדת לכל אורך התכנית שלכם או לאו, והאם אתם רוצים שכך יהיה. רוב הזמן, הודעת שגיאה שמציעה להשתמש במשך החיים `'static` נובעת מניסיון ליצור הפניה משתלשלת או מחוסר התאמה בין משכי-החיים שבנמצא. במקרים כאלה, הפתרון נעוץ בפתרון בעיות אלה, ולא בשימוש במשך החיים `'static`.

## פרמטרי טיפוס גנריים, מגבלות תכונה, ומשכי-חיים כולם יחדיו

הבה נעיף מבט בתחביר לציון פרמטרי טיפוס גנריים, מגבלות תכונה, ומשכי-חיים, כולם בפונקציה אחת!

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-11-generics-traits-and-lifetimes/src/main.rs:here}}
```

זוהי הפונקציה `longest` f מרשימה 10-21 שמחזירה את המחרוזת הארוכה מבין שני חיתוכי מחרוזת. אבל הפעם יש לה פרמטר נוסף בשם `ann` מהטיפוס הגנרי `T`, שניתן להחליפו בכל טיפוס שמממש את התכונה `Display`, כפי שמצויין על-ידי ה-`where`. פרמטר נוסף זה יודפס תוך שימוש ב- `{}`, וזו הסיבה לכך שהתכונה `Display` הכרחית. היות ומשכי-חיים הם סוג של ג'נריק, ההכרזות של פרמטר משך-החיים `'a` ושל פרמטר הטיפוס הגנרי `T` נמצאים באותה הרשימה בתוך סוגריים משולשים אחרי שם הפונקציה.

## סיכום

כיסינו הרבה חומר בפרק זה! כעת, כשאתם יודעים אודות פרמטרי טיפוס גנריים, תכונות ומגבלות תכונה, ופרמטרי משך-חיים גנריים, אתם מוכנים לכתוב קוד ללא שכפול שעובד במצבים רבים ושונים. פרמטרי טיפוס גנריים מאפשרים לכם ליישם את הקוד עבור טיפוסים שונים. תכונות ומגבלות תכונה מוודאים שאפילו כאשר טיפוסים הם גנריים, הם עדיין יתנהגו כפי שהקוד דורש. למדתם כיצד להשתמש בביאורי משך-חיים כדי להבטיח שקוד גמיש זה לא יצור הפניות משתלשלות. וכל הניתוחים האלה מתבצעים בזמן הקומפילציה, ואינם משפיעים לרעה על יעילות הריצה!

תאמינו או לא, אבל יש עוד הרבה מה להוסיף אודות הנושאים בהם דנו בפרק זה: פרק 17 דן באובייקטי תכונה, שהם דרך נוספת להשתמש בתכונות. יש מצבים יותר סבוכים המערבים ביאורי משך-חיים שישמשו אתכם במצבים מתקדמים למדי; עבור אלה, פנו [לתיעוד של ראסט][reference]. אבל עכשיו תעברו ללמוד איך לכתוב מבחנים בראסט כדי שתוכלו לוודא שהקוד שלכם פועל כשורה.
ch04-02-references-and-borrowing.html#references-and-borrowing ch04-03-slices.html#string-slices-as-parameters

[reference]: ../reference/index.html
